/* Csi.OsLoader.SimpleSRecord.h

   Copyright (C) 2007, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 08 May 2007
   Last Change: Thursday 27 January 2011
   Last Commit: $Date: 2011-01-27 12:51:49 -0600 (Thu, 27 Jan 2011) $
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Csi_OsLoader_SimpleSRecord_h
#define Csi_OsLoader_SimpleSRecord_h

#include "Csi.OsLoader.OsLoaderBase.h"
#include "OneShot.h"
#include "Csi.ByteQueue.h"
#include <list>


namespace Csi
{
   namespace OsLoader
   {
      ////////////////////////////////////////////////////////////
      // class SimpleSRecord
      //
      // Defines an object that implements the "simplified" S-Record protocol
      // implemented for the RF500 device type.
      ////////////////////////////////////////////////////////////
      class SimpleSRecord:
         public OsLoaderBase,
         public OneShotClient
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         typedef SharedPtr<OneShot> timer_handle;
         SimpleSRecord(timer_handle &timer_);

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~SimpleSRecord();

         ////////////////////////////////////////////////////////////
         // get_file_extension
         ////////////////////////////////////////////////////////////
         virtual char const *get_file_extension()
         {
            char const *rtn(OsLoaderBase::get_file_extension());
            if(rtn[0] == 0)
               rtn = "*.mot";
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // open_and_validate
         ////////////////////////////////////////////////////////////
         virtual void open_and_validate(
            char const *os_file_name);

         ////////////////////////////////////////////////////////////
         // start_send
         ////////////////////////////////////////////////////////////
         virtual void start_send(
            driver_handle driver,
            EventReceiver *client);

         ////////////////////////////////////////////////////////////
         // cancel_send
         ////////////////////////////////////////////////////////////
         virtual void cancel_send();

         ////////////////////////////////////////////////////////////
         // on_receive
         ////////////////////////////////////////////////////////////
         virtual void on_receive(
            OsLoaderDriver *driver,
            void const *buff,
            uint4 buff_len);

      protected:
         ////////////////////////////////////////////////////////////
         // on_complete
         ////////////////////////////////////////////////////////////
         virtual void on_complete(
            char const *message,
            bool succeeded);

         ////////////////////////////////////////////////////////////
         // onOneShotFired
         ////////////////////////////////////////////////////////////
         virtual void onOneShotFired(uint4 event_id);

      private:
         ////////////////////////////////////////////////////////////
         // send_status
         ////////////////////////////////////////////////////////////
         void send_status(char const *msg);
         
         ////////////////////////////////////////////////////////////
         // on_error
         ////////////////////////////////////////////////////////////
         void on_error(char const *message);

         ////////////////////////////////////////////////////////////
         // send_next_srecord
         ////////////////////////////////////////////////////////////
         void send_next_srecord();

         ////////////////////////////////////////////////////////////
         // check_for_ack
         ////////////////////////////////////////////////////////////
         void check_for_ack();

      private:
         ////////////////////////////////////////////////////////////
         // os_file_name
         ////////////////////////////////////////////////////////////
         StrAsc os_file_name;

         ////////////////////////////////////////////////////////////
         // records
         //
         // Contains the set of srecords that were read from the file when opened.
         ////////////////////////////////////////////////////////////
         typedef std::list<StrAsc> records_type;
         records_type records;

         ////////////////////////////////////////////////////////////
         // current_record
         ////////////////////////////////////////////////////////////
         records_type::iterator current_record;

         ////////////////////////////////////////////////////////////
         // timer
         ////////////////////////////////////////////////////////////
         timer_handle timer;

         ////////////////////////////////////////////////////////////
         // file_size_bytes
         ////////////////////////////////////////////////////////////
         uint4 file_size_bytes;

         ////////////////////////////////////////////////////////////
         // bytes_sent
         ////////////////////////////////////////////////////////////
         uint4 bytes_sent;

         ////////////////////////////////////////////////////////////
         // state
         ////////////////////////////////////////////////////////////
         enum state_type
         {
            state_standby,
            state_open,
            state_waiting_for_first,
            state_sending,
            state_error
         } state;

         ////////////////////////////////////////////////////////////
         // get_ack_id
         ////////////////////////////////////////////////////////////
         uint4 get_ack_id;

         ////////////////////////////////////////////////////////////
         // retry_count
         ////////////////////////////////////////////////////////////
         uint4 retry_count;

         ////////////////////////////////////////////////////////////
         // receive_buffer
         ////////////////////////////////////////////////////////////
         ByteQueue receive_buffer;

         ////////////////////////////////////////////////////////////
         // records_sent
         ////////////////////////////////////////////////////////////
         uint4 records_sent;

         ////////////////////////////////////////////////////////////
         // first_base
         //
         // Used to keep track of the time elapsed while attempting to send the
         // first fragment.  We allow extra time for the first because it may
         // take longer for the user to get the device powered up.
         ////////////////////////////////////////////////////////////
         uint4 first_base;
      };
   };
};


#endif
