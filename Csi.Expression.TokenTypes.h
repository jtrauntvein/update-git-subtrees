/* Csi.Expression.TokenTypes.h

   Copyright (C) 2002, 2020 Campbell Scientific, Inc.

   Written by: Tyler Mecham
   Date Begun: 9 january 2002
   Last Change: Saturday 18 April 2020
   Last Commit: $Date: 2020-04-18 06:31:20 -0600 (Sat, 18 Apr 2020) $
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Csi_Expression_TokenTypes_h
#define Csi_Expression_TokenTypes_h

#include "Csi.Expression.Token.h"
#include "Cora.DataSources.Request.h"
#include "StrAsc.h"
#include "Csi.MsgExcept.h"
#include "Csi.Utils.h"
#include "Csi.LightSharedPtr.h"
#include "Csi.LgrDate.h"
#include "CsiTypes.h"
#include "trace.h"
#include <iostream>
#include <limits>
#include <deque>
#include <time.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include <map>


namespace Csi
{
   namespace Expression
   {


      ////////////////////////////////////////////////////////////
      // Class Addition
      //
      // Represents the + operator
      //////////////////////////////////////////////////////////// 
      class Addition: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Addition()
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Addition()
         {}

         //@group Token virtual function implementations
         ////////////////////////////////////////////////////////////
         // eval
         //////////////////////////////////////////////////////////// 
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_add_subtr; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator () const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "+"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Addition *clone() const
         { return new Addition; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAddition.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAddition()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
         
         //@endgroup
      };


      ////////////////////////////////////////////////////////////
      // Class Subtraction
      //
      // Represents the - operator
      //////////////////////////////////////////////////////////// 
      class Subtraction: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Subtraction()
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Subtraction()
         {}

         //@group Token virtual function implementations
         ////////////////////////////////////////////////////////////
         // eval
         //////////////////////////////////////////////////////////// 
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_add_subtr; }

         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "-"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Subtraction *clone() const
         { return new Subtraction; }

         //@endgroup

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSubtraction.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSubtraction()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // Class Multiplication
      //
      // Represents the * operator
      //////////////////////////////////////////////////////////// 
      class Multiplication : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Multiplication(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Multiplication(){}

         //@group Token virtual function implementations
         ////////////////////////////////////////////////////////////
         // eval
         //////////////////////////////////////////////////////////// 
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);
         
         virtual uint2 get_priority() const
         { return prec_mult_div_mod; }

         virtual bool is_operator () const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "*"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Multiplication *clone() const
         { return new Multiplication; }
         //@endgroup

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMultiplication.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMultiplication()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // Class Division
      //
      // Represents the / operator
      //////////////////////////////////////////////////////////// 
      class Division : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Division()
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Division()
         {}

         //@group Token virtual function implementations
         ////////////////////////////////////////////////////////////
         // eval
         //////////////////////////////////////////////////////////// 
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);
         
         virtual uint2 get_priority() const
         { return prec_mult_div_mod; }

         virtual bool is_operator () const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "/"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Division *clone() const
         { return new Division; }
         //@endgroup

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiDivision.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiDivision()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // Class Exponentiation
      //
      // Raises the first operand to the power of the other (numbers only)
      //////////////////////////////////////////////////////////// 
      class Exponentiation : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Exponentiation()
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Exponentiation(){}

         //@group Token virtual function implementations
         ////////////////////////////////////////////////////////////
         // eval
         //////////////////////////////////////////////////////////// 
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_expon; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator () const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "^"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Exponentiation *clone() const
         { return new Exponentiation; }
         
         //@endgroup

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiExponentiation.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiExponentiation()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // Class Negation
      //
      // Negates the operand
      //////////////////////////////////////////////////////////// 
      class Negation : public Token
      {
      private:
         StrUni const name;
         
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Negation(StrUni const &name_):
            name(name_)
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Negation()
         {}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         virtual uint2 get_priority() const
         { return prec_negation; }

         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << name; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Negation *clone() const
         { return new Negation(name); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiNegation.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiNegation()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class CsgnFunction
      ////////////////////////////////////////////////////////////
      class CsgnFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         CsgnFunction()
         { }

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~CsgnFunction()
         { }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         { return argument_type_number; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual CsgnFunction *clone() const
         { return new CsgnFunction; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "CSGN"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }

         /**
          * Overrides the base class to generate a dependency on the negation module.
          */
         virtual StrAsc get_js_resource() const
         { return "CsiNegation.js"; }

         /**
          * Overrides the base class version to generate the javascript instantiation of this
          * function.
          */
         virtual void format_js(std::ostream &out)
         { out << "new CsiNegation()"; }
      };

        
      ////////////////////////////////////////////////////////////
      // Class Comma
      //
      // Place holder in infix expressions
      //////////////////////////////////////////////////////////// 
      class Comma : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Comma(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Comma(){}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression)
         { }
            
         virtual uint2 get_priority() const
         { return prec_comma; }

         virtual bool is_comma() const
         { return true; }

         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << ","; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Comma *clone() const
         { return new Comma; }
      };


      ////////////////////////////////////////////////////////////
      // Class LeftParen
      //
      // Placeholder in in-fix expressions
      //////////////////////////////////////////////////////////// 
      class LeftParen : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         LeftParen(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~LeftParen(){}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression)
         { }
            
         virtual uint2 get_priority() const
         { return prec_paren; }

         virtual bool is_lparen() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "("; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual LeftParen *clone() const
         { return new LeftParen; }

      };

      
      ////////////////////////////////////////////////////////////
      // Class RightParen
      //
      // Placeholder in infix expressions
      //////////////////////////////////////////////////////////// 
      class RightParen : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         RightParen(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~RightParen(){}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression)
         { }
            
         virtual uint2 get_priority() const
         { return prec_paren; }

         virtual bool is_rparen() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << ")"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual RightParen *clone() const
         { return new RightParen; }

      };


      ////////////////////////////////////////////////////////////
      // class SemiColon
      ////////////////////////////////////////////////////////////
      class SemiColon: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         SemiColon()
         { }

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~SemiColon()
         { }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression)
         { }

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_semi_colon; }

         ////////////////////////////////////////////////////////////
         // is_semi_colon
         ////////////////////////////////////////////////////////////
         virtual bool is_semi_colon() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << ";"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual SemiColon *clone() const
         { return new SemiColon; }
      };


      ////////////////////////////////////////////////////////////
      // class PwrFunction
      ////////////////////////////////////////////////////////////
      class PwrFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         PwrFunction()
         { }

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~PwrFunction()
         { }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            if(index == 0)
               rtn = L"base";
            else if(index == 1)
               rtn = L"exponent";
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         { return argument_type_number; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "PWR"; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiExponentiation.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiExponentiation()"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual PwrFunction *clone() const
         { return new PwrFunction; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ToDate
      ////////////////////////////////////////////////////////////
      class ToDate: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ToDate"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ToDate *clone() const
         { return new ToDate; }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiToDate.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiToDate()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("unsupported argument index");
            return L"value";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_conversion_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ToFloat
      ////////////////////////////////////////////////////////////
      class ToFloat: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ToFloat"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ToFloat *clone() const
         { return new ToFloat; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiToFloat.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiToFloat()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"value";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_conversion_function; }
      };
      

      ////////////////////////////////////////////////////////////
      // class ToInt
      ////////////////////////////////////////////////////////////
      class ToInt: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ToInt"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ToInt *clone() const
         { return new ToInt; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiToInt.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiToInt()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"value";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_conversion_function; }
      };


      ////////////////////////////////////////////////////////////
      // class AbsoluteValue
      //
      // Evaluates the absolute value of the operand
      ////////////////////////////////////////////////////////////
      class AbsoluteValue: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         AbsoluteValue(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~AbsoluteValue(){}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);
         
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ABS"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual AbsoluteValue *clone() const
         { return new AbsoluteValue; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAbsoluteValue.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAbsoluteValue()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ArcCosine
      ////////////////////////////////////////////////////////////
      class ArcCosine: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         ArcCosine(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~ArcCosine(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ACOS"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ArcCosine *clone() const
         { return new ArcCosine; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiArcCosine.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiArcCosine()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class AndOperator
      //
      // Performs the bitwise and of two integers (or the integer representation of floats) 
      ////////////////////////////////////////////////////////////
      class AndOperator: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         AndOperator(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~AndOperator(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_logic_op; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "AND"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual AndOperator *clone() const
         { return new AndOperator; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAndOperator.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAndOperator()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class ArcSine
      ////////////////////////////////////////////////////////////
      class ArcSine: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         ArcSine(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~ArcSine(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ASIN"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ArcSine *clone() const
         { return new ArcSine; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiArcSine.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiArcSine()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ArcTangent
      ////////////////////////////////////////////////////////////
      class ArcTangent: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         ArcTangent(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~ArcTangent(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ATN"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ArcTangent *clone() const
         { return new ArcTangent; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiArcTangent.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiArcTangent()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ArcTangent2
      ////////////////////////////////////////////////////////////
      class ArcTangent2: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         ArcTangent2(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~ArcTangent2(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ATN2"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ArcTangent2 *clone() const
         { return new ArcTangent2; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiArcTangent2.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiArcTangent2()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"y";
               break;
               
            case 1:
               rtn = L"x";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Cosine
      ////////////////////////////////////////////////////////////
      class Cosine: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Cosine(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Cosine(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "COS"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Cosine *clone() const
         { return new Cosine; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiCosine.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiCosine()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"angle";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class HyperbolicCosine
      ////////////////////////////////////////////////////////////
      class HyperbolicCosine: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         HyperbolicCosine(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~HyperbolicCosine(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "COSH"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual HyperbolicCosine *clone() const
         { return new HyperbolicCosine; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiHyperbolicCosine.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiHyperbolicCosine()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"angle";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };

        
      ////////////////////////////////////////////////////////////
      // class Equivalence
      ////////////////////////////////////////////////////////////
      class Equivalence: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Equivalence(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Equivalence(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "EQV"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Equivalence *clone() const
         { return new Equivalence; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiEquivalence.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiEquivalence()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class EtoPower
      ////////////////////////////////////////////////////////////
      class EtoPower: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         EtoPower(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~EtoPower(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "EXP"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual EtoPower *clone() const
         { return new EtoPower; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiEtoPower.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiEtoPower()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"exponent";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Fix
      ////////////////////////////////////////////////////////////
      class Fix: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Fix(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Fix(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "FIX"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Fix *clone() const
         { return new Fix; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiFix.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiFix()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      class IsFinite: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         IsFinite(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~IsFinite(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "IsFinite"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual IsFinite *clone() const
         { return new IsFinite; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiIsFinite.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiIsFinite()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"value";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class FractionalPart
      ////////////////////////////////////////////////////////////
      class FractionalPart: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         FractionalPart(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~FractionalPart(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "FRAC"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual FractionalPart *clone() const
         { return new FractionalPart; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiFractionalPart.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiFractionalPart()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class IIF
      ////////////////////////////////////////////////////////////
      class IIF: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         IIF(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~IIF(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "IIF"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual IIF *clone() const
         { return new IIF; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiIIF.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiIIF()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"predicate";
               break;
               
            case 1:
               rtn = L"trueValue";
               break;
               
            case 2:
               rtn = L"falseValue";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class Switch
      ////////////////////////////////////////////////////////////
      class Switch: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // args_count
         ////////////////////////////////////////////////////////////
         uint4 args_count;
         
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         Switch():
            args_count(0)
         { }

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~Switch()
         { }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SelectSwitch"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Switch *clone() const
         { return new Switch; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }
         
         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSwitchFunction.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSwitchFunction(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_max_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_max_arguments()
         { return 0xFFFFFFFF; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            if(args_count == 0)
            {
               if(index == 0)
                  rtn = L"predicate";
               else if(index == 1)
                  rtn = L"value";
               else
                  rtn = L"defaultValue";
            }
            else
            {
               if(index + 1 == args_count)
                  rtn = L"default_value";
               else if(index % 2 == 0)
                  rtn = L"predicate_i";
               else
                  rtn = L"value_i";
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }

         ////////////////////////////////////////////////////////////
         // clear_args_count
         ////////////////////////////////////////////////////////////
         virtual void clear_args_count()
         { args_count = 1; }

         ////////////////////////////////////////////////////////////
         // increment_args_count
         ////////////////////////////////////////////////////////////
         virtual void increment_args_count()
         { ++args_count; }
      };


      ////////////////////////////////////////////////////////////
      // class Implication
      ////////////////////////////////////////////////////////////
      class Implication: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Implication(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Implication(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "IMP"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Implication *clone() const
         { return new Implication; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiImplication.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiImplication()"; }

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_bit_op; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class Int
      ////////////////////////////////////////////////////////////
      class Int: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Int(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Int(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "INT"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Int *clone() const
         { return new Int; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiInt.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiInt()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class NaturalLog
      ////////////////////////////////////////////////////////////
      class NaturalLog: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // name
         ////////////////////////////////////////////////////////////
         StrUni name;
         
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         NaturalLog(StrUni const &name_):
            name(name_)
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~NaturalLog(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << name; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual NaturalLog *clone() const
         { return new NaturalLog(name); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiNaturalLog.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiNaturalLog()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class LogBase10
      ////////////////////////////////////////////////////////////
      class LogBase10: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         LogBase10(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~LogBase10(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "LOG10"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual LogBase10 *clone() const
         { return new LogBase10; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLogBase10.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLogBase10()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // Class Modulo
      //////////////////////////////////////////////////////////// 
      class Modulo: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Modulo(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Modulo(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MOD"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Modulo *clone() const
         { return new Modulo; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiModulo.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiModulo()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"dividend";
               break;

            case 1:
               rtn = L"divisor";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_operator; }

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_mult_div_mod; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }
      };


      ////////////////////////////////////////////////////////////
      // class NotOperator
      ////////////////////////////////////////////////////////////
      class NotOperator: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         NotOperator()
         {}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~NotOperator()
         {}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "NOT"; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiNot.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiNotOperator()"; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_logic_op; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual NotOperator *clone() const
         { return new NotOperator; }
      };


      ////////////////////////////////////////////////////////////
      // class OrOperator
      ////////////////////////////////////////////////////////////
      class OrOperator : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         OrOperator(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~OrOperator(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_bit_op; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "OR"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual OrOperator  *clone() const
         { return new OrOperator ; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiOrOperator.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiOrOperator()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class Random
      ////////////////////////////////////////////////////////////
      class Random: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Random()
         {
            //seed the random number generator
            srand( static_cast<unsigned>(time( 0 )) );
         }

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Random(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "RND"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Random *clone() const
         { return new Random; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiRandom.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiRandom()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 0; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { throw std::invalid_argument("invalid argument index"); }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Sign
      ////////////////////////////////////////////////////////////
      class Sign: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Sign(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Sign(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SGN"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Sign *clone() const
         { return new Sign; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSign.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSign()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Sine
      ////////////////////////////////////////////////////////////
      class Sine: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Sine(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Sine(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SIN"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Sine *clone() const
         { return new Sine; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSine.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSine()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"angle";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class HyperbolicSine
      ////////////////////////////////////////////////////////////
      class HyperbolicSine: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         HyperbolicSine(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~HyperbolicSine(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SINH"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual HyperbolicSine *clone() const
         { return new HyperbolicSine; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiHyperbolicSine.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiHyperbolicSine()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"angle";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class SquareRoot
      ////////////////////////////////////////////////////////////
      class SquareRoot: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         SquareRoot(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~SquareRoot(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SQR"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual SquareRoot *clone() const
         { return new SquareRoot; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSquareRoot.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSquareRoot()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"number";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Tangent
      ////////////////////////////////////////////////////////////
      class Tangent: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Tangent(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Tangent(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "TAN"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Tangent *clone() const
         { return new Tangent; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiTangent.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiTangent()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"angle";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class HyperbolicTangent
      ////////////////////////////////////////////////////////////
      class HyperbolicTangent: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         HyperbolicTangent(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~HyperbolicTangent(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "TANH"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual HyperbolicTangent *clone() const
         { return new HyperbolicTangent; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiHyperbolicTangent.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiHyperbolicTangent()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"angle";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class XOrOperator
      ////////////////////////////////////////////////////////////
      class XOrOperator: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         XOrOperator(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~XOrOperator(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_bit_op; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "XOR"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual XOrOperator *clone() const
         { return new XOrOperator; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiXorOperator.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiXorOperator()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_logical_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class IsEqual
      ////////////////////////////////////////////////////////////
      class IsEqual : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         IsEqual(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~IsEqual(){}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "="; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual IsEqual  *clone() const
         { return new IsEqual ; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiIsEqual.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiIsEqual()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class NotEqual
      ////////////////////////////////////////////////////////////
      class NotEqual: public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         NotEqual(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~NotEqual(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "<>"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual NotEqual *clone() const
         { return new NotEqual; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiNotEqual.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiNotEqual()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };
   

      ////////////////////////////////////////////////////////////
      // class Greater
      ////////////////////////////////////////////////////////////
      class Greater : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Greater(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Greater(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << ">"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Greater  *clone() const
         { return new Greater ; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiGreater.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiGreater()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class Less
      ////////////////////////////////////////////////////////////
      class Less : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         Less(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~Less(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "<"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Less  *clone() const
         { return new Less ; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLess.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLess()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class GreaterEqual
      ////////////////////////////////////////////////////////////
      class GreaterEqual : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         GreaterEqual(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~GreaterEqual(){}

         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << ">="; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual GreaterEqual  *clone() const
         { return new GreaterEqual ; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiGreaterEqual.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiGreaterEqual()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // LessEqual
      ////////////////////////////////////////////////////////////
      class LessEqual : public Token
      {
      public:
         ////////////////////////////////////////////////////////////
         // Constructor
         //////////////////////////////////////////////////////////// 
         LessEqual(){}

         ////////////////////////////////////////////////////////////
         // Destructor
         //////////////////////////////////////////////////////////// 
         virtual ~LessEqual(){}

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 
            
         ////////////////////////////////////////////////////////////
         // get_priority
         ////////////////////////////////////////////////////////////
         virtual uint2 get_priority() const
         { return prec_comparator; }

         ////////////////////////////////////////////////////////////
         // is_operator
         ////////////////////////////////////////////////////////////
         virtual bool is_operator() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "<="; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual LessEqual  *clone() const
         { return new LessEqual ; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLessEqual.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLessEqual()"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_operator; }
      };


      ////////////////////////////////////////////////////////////
      // class StrComp
      ////////////////////////////////////////////////////////////
      class StrComp: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StrComp"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StrComp *clone() const
         { return new StrComp; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiStrComp.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiStrComp()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"string1";
               break;
               
            case 1:
               rtn = L"string2";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class InStr
      ////////////////////////////////////////////////////////////
      class InStr: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "InStr"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual InStr *clone() const
         { return new InStr; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiInStr.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiInStr()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 1:
               rtn = L"source";
               break;
               
            case 2:
               rtn = L"pattern";
               break;
               
            case 0:
               rtn = L"start";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class InStrRev
      ////////////////////////////////////////////////////////////
      class InStrRev: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "InStrRev"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual InStrRev *clone() const
         { return new InStrRev; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiInStrRev.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiInStrRev()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 1:
               rtn = L"source";
               break;
               
            case 2:
               rtn = L"pattern";
               break;
               
            case 0:
               rtn = L"start";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class StrReverse
      ////////////////////////////////////////////////////////////
      class StrReverse: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StrReverse"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StrReverse *clone() const
         { return new StrReverse; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiStrReverse.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiStrReverse()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"source";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Space
      ////////////////////////////////////////////////////////////
      class Space: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Space"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Space *clone() const
         { return new Space; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSpace.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSpace()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"count";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Len
      ////////////////////////////////////////////////////////////
      class Len: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Len"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Len *clone() const
         { return new Len; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLen.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLen()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            if(index != 0)
               throw std::invalid_argument("invalid argument index");
            return L"string";
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Left
      ////////////////////////////////////////////////////////////
      class Left: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Left"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Left *clone() const
         { return new Left; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLeft.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLeft()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;
               
            case 1:
               rtn = L"count";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Right
      ////////////////////////////////////////////////////////////
      class Right: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Right"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Right *clone() const
         { return new Right; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiRight.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiRight()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;

            case 1:
               rtn = L"count";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class LTrim
      ////////////////////////////////////////////////////////////
      class LTrim: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "LTrim"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual LTrim *clone() const
         { return new LTrim; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLTrim.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLTrim()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class RTrim
      ////////////////////////////////////////////////////////////
      class RTrim: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "RTrim"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual RTrim *clone() const
         { return new RTrim; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiRTrim.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiRTrim()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Trim
      ////////////////////////////////////////////////////////////
      class Trim: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Trim"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Trim *clone() const
         { return new Trim; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiTrim.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiTrim()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Mid
      ////////////////////////////////////////////////////////////
      class Mid: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Mid"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Mid *clone() const
         { return new Mid; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMid.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMid()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;

            case 1:
               rtn = L"start";
               break;

            case 2:
               rtn = L"count";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Replace
      ////////////////////////////////////////////////////////////
      class Replace: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Replace"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Replace *clone() const
         { return new Replace; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiReplace.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiReplace()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 5; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"source";
               break;

            case 1:
               rtn = L"pattern";
               break;

            case 2:
               rtn = L"replacement";
               break;

            case 3:
               rtn = L"start";
               break;

            case 4:
               rtn = L"count";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Last
      //
      // Defines a function that stores its parameter and returns the last
      // parameter with which it was called. 
      ////////////////////////////////////////////////////////////
      class Last: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // previous
         ////////////////////////////////////////////////////////////
         value_type previous_value;

         ////////////////////////////////////////////////////////////
         // previous_time
         ////////////////////////////////////////////////////////////
         LgrDate previous_time;

         ////////////////////////////////////////////////////////////
         // was_set
         ////////////////////////////////////////////////////////////
         bool was_set;
         
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         Last():
            was_set(false)
         {
            previous_value.type = value_double;
            previous_value.vdouble = std::numeric_limits<double>::quiet_NaN();
         }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Last"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Last *clone() const
         { return new Last; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         {
            previous_value.type = value_double;
            previous_value.vdouble = std::numeric_limits<double>::quiet_NaN();
            was_set = false;
         }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLast.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLast()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"value";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class FormatFloat
      ////////////////////////////////////////////////////////////
      class FormatFloat: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "FormatFloat"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual FormatFloat *clone() const
         { return new FormatFloat; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiFormatFloat.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiFormatFloat()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"value";
               break;

            case 1:
               rtn = L"format";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class FormatFloatL
      ////////////////////////////////////////////////////////////
      class FormatFloatL: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression); 

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "FormatFloatL"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual FormatFloatL *clone() const
         { return new FormatFloatL; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiFormatFloat.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiFormatFloat()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"value";
               break;

            case 1:
               rtn = L"format";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class AvgRun
      //
      // Implements a "running average" over the number of samples specified as
      // a function argument.
      ////////////////////////////////////////////////////////////
      class AvgRun: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         std::deque<double> last_values;

         ////////////////////////////////////////////////////////////
         // insert_pos
         ////////////////////////////////////////////////////////////
         size_t insert_pos;

         ////////////////////////////////////////////////////////////
         // total
         ////////////////////////////////////////////////////////////
         double total;
         
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         AvgRun();
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "AvgRun"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual AvgRun *clone() const
         { return new AvgRun; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         {
            last_values.clear();
            total = std::numeric_limits<double>::quiet_NaN();
         }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAvgRun.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAvgRun()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"count";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class AvgSpa
      //
      // Implements a function that calculates the average of the arguments passed in. 
      ////////////////////////////////////////////////////////////
      class AvgSpa: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // args_count
         ////////////////////////////////////////////////////////////
         uint4 args_count;
         
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         AvgSpa():
            args_count(0)
         { }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "AvgSpa"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual AvgSpa *clone() const
         { return new AvgSpa; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAvgSpa.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAvgSpa(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // clear_args_count
         ////////////////////////////////////////////////////////////
         virtual void clear_args_count()
         { args_count = 1; }

         ////////////////////////////////////////////////////////////
         // increment_args_count
         ////////////////////////////////////////////////////////////
         virtual void increment_args_count()
         { ++args_count; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_max_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_max_arguments()
         { return 0xFFFFFFFF; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { return L"number"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // MaxRun
      //
      // Defines a function that calculates the maximum value of any argument
      // passed. 
      ////////////////////////////////////////////////////////////
      class MaxRun: public Function
      {
      private:
         ///////////////////////////////////////////////////////////
         // max_value
         ///////////////////////////////////////////////////////////
         value_type max_value;
         
         ///////////////////////////////////////////////////////////
         // max_timestamp
         ///////////////////////////////////////////////////////////
         Csi::LgrDate max_timestamp;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MaxRun()
         { reset_state(); }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MaxRun"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MaxRun *clone() const
         { return new MaxRun; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         {
            max_value.type = value_double;
            max_value.vdouble = std::numeric_limits<double>::quiet_NaN();
            max_timestamp = 0;
         }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMaxRun.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMaxRun()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class MinRun
      //
      // Defines a stateful function that evaluates the minimum value of all evaluated
      ////////////////////////////////////////////////////////////
      class MinRun: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // min_value
         ////////////////////////////////////////////////////////////
         value_type min_value;
         
         ///////////////////////////////////////////////////////////
         // min_timestamp
         ///////////////////////////////////////////////////////////
         Csi::LgrDate min_timestamp;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MinRun()
         { reset_state(); }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MinRun"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MinRun *clone() const
         { return new MinRun; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         {
            min_value.type = value_double;
            min_value.vdouble = std::numeric_limits<double>::quiet_NaN();
            min_timestamp = 0;
         }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMinRun.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMinRun()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"count";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class MedianRun
      //
      // Defines a function object that calculates a "running median" or, in other words, the median
      // of the last specified number of values.
      ////////////////////////////////////////////////////////////
      class MedianRun: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::deque<double> last_values_type;
         last_values_type last_values;

      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MedianRun"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MedianRun *clone() const
         { return new MedianRun; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { last_values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMedianRun.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMedianRun()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"count";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ValueAtTime
      //
      // Implements a buffer of values based on a time range and then
      // indexes into the buffer.
      ////////////////////////////////////////////////////////////
      class ValueAtTime: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::map<Csi::LgrDate,value_type> last_values_type;
         last_values_type last_values;

         ///////////////////////////////////////////////////////////
         // report_default
         ///////////////////////////////////////////////////////////
         bool report_default;
         
      public:
         ///////////////////////////////////////////////////////////
         // Constructor
         ///////////////////////////////////////////////////////////
         ValueAtTime():
            report_default(true)
         { }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ValueAtTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ValueAtTime *clone() const
         { return new ValueAtTime; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         {
            report_default = true;
            last_values.clear();
         }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiValueAtTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiValueAtTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 4; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"value";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;

            case 3:
               rtn = L"defaultValue";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ///////////////////////////////////////////////////////////
      // class Timestamp
      //
      // Retrieves the timestamp from an Variable
      ///////////////////////////////////////////////////////////
      class Timestamp: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Timestamp"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Timestamp *clone() const
         { return new Timestamp; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiTimestamp.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiTimestamp()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"value";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };


      ////////////////////////////////////////////////////////////
      // class SetTimestamp
      //
      // Defines an expression function that can be used to set the time stamp
      // for the return value which will be copied from the first argument. 
      ////////////////////////////////////////////////////////////
      class SetTimestamp: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SetTimestamp"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual SetTimestamp *clone() const
         { return new SetTimestamp; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSetTimestamp.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSetTimestamp()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"value";
               break;

            case 1:
               rtn = L"value_timestamp";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };
      

      ////////////////////////////////////////////////////////////
      // class AvgRunOverTime
      ////////////////////////////////////////////////////////////
      class AvgRunOverTime: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate,value_type> last_values_type;
         last_values_type last_values;
         
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "AvgRunOverTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual AvgRunOverTime *clone() const
         { return new AvgRunOverTime; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { last_values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAvgRunOverTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAvgRunOverTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };

      ////////////////////////////////////////////////////////////
      // class MaxRunOverTime
      ////////////////////////////////////////////////////////////
      class MaxRunOverTime: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate,value_type> last_values_type;
         last_values_type last_values;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MaxRunOverTime()
         { reset_state(); }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MaxRunOverTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MaxRunOverTime *clone() const
         { return new MaxRunOverTime; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { last_values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMaxRunOverTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMaxRunOverTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };
 
      ////////////////////////////////////////////////////////////
      // class MinRunOverTime
      ////////////////////////////////////////////////////////////
      class MinRunOverTime: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate,value_type> last_values_type;
         last_values_type last_values;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MinRunOverTime()
         { reset_state(); }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MinRunOverTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MinRunOverTime *clone() const
         { return new MinRunOverTime; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { last_values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMinRunOverTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMinRunOverTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };

      ////////////////////////////////////////////////////////////
      // class MedianRunOverTime
      ////////////////////////////////////////////////////////////
      class MedianRunOverTime: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate, double> last_values_type;
         last_values_type last_values;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MedianRunOverTime()
         { reset_state(); }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MedianRunOverTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MedianRunOverTime *clone() const
         { return new MedianRunOverTime; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { last_values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMedianRunOverTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMedianRunOverTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class SystemTime
      ////////////////////////////////////////////////////////////
      class SystemTime: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression)
         {
            LightPolySharedPtr<Token, Operand> result(new Operand);
            Csi::LgrDate now(Csi::LgrDate::system());
            result->set_val_date(now.get_nanoSec(), now);
            stack.push_back(result.get_handle());
         }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SystemTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual SystemTime *clone() const
         { return new SystemTime; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSystemTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSystemTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 0; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { throw std::invalid_argument("invalid argument index"); }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };


      ////////////////////////////////////////////////////////////
      // class SystemTimeGmt
      ////////////////////////////////////////////////////////////
      class SystemTimeGmt: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression)
         {
            LightPolySharedPtr<Token, Operand> result(new Operand);
            LgrDate now(LgrDate::gmt());
            result->set_val_date(now.get_nanoSec(), now);
            stack.push_back(result.get_handle());
         }

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "SystemTimeGmt"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual SystemTimeGmt *clone() const
         { return new SystemTimeGmt; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiSystemTimeGmt.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiSystemTimeGmt()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 0; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { throw std::invalid_argument("invalid argument index"); }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };


      ////////////////////////////////////////////////////////////
      // class FormatTime
      ////////////////////////////////////////////////////////////
      class FormatTime: public Function
      {
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "FormatTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual FormatTime *clone() const
         { return new FormatTime; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiFormatTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiFormatTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"time";
               break;

            case 1:
               rtn = L"format";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Total
      ////////////////////////////////////////////////////////////
      class Total: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // sum
         ////////////////////////////////////////////////////////////
         double sum;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         Total():
            sum(std::numeric_limits<double>::quiet_NaN())
         { }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Total"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Total *clone() const
         { return new Total; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { sum = 0.0; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiTotal.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiTotal()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };

      
      ////////////////////////////////////////////////////////////
      // class TotalOverTime
      ////////////////////////////////////////////////////////////
      class TotalOverTime: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate,value_type> last_values_type;
         last_values_type last_values;

      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "TotalOverTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual TotalOverTime *clone() const
         { return new TotalOverTime; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { last_values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiTotalOverTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiTotalOverTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ResettableBase
      ////////////////////////////////////////////////////////////
      class ResettableBase: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         ResettableBase(uint4 args_count_ = 0):
            args_count(args_count_)
         { }
         
         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         {
            last_values.clear();
         }

         ////////////////////////////////////////////////////////////
         // add_value
         ////////////////////////////////////////////////////////////
         void add_value(double val, LgrDate const &time, int8 reset_option, int8 reset_arg = 0);

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }

         ////////////////////////////////////////////////////////////
         // clear_args_count
         ////////////////////////////////////////////////////////////
         virtual void clear_args_count()
         { args_count = 1; }

         ////////////////////////////////////////////////////////////
         // increment_args_count
         ////////////////////////////////////////////////////////////
         virtual void increment_args_count()
         { ++args_count; }
         
      protected:
         ////////////////////////////////////////////////////////////
         // last_values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate, double> last_values_type;
         last_values_type last_values;

         ////////////////////////////////////////////////////////////
         // args_count
         ////////////////////////////////////////////////////////////
         uint4 args_count;

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiResettableBase.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiResettableBase(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_max_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_max_arguments()
         { return 4; }
         
         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"resetOption";
               break;

            case 3:
               rtn = L"resetFlag";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }
      };

      
      ////////////////////////////////////////////////////////////
      // class TotalOverTimeWithReset
      ////////////////////////////////////////////////////////////
      class TotalOverTimeWithReset: public ResettableBase
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         TotalOverTimeWithReset(uint4 args_count_ = 0):
            ResettableBase(args_count_)
         { }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "TotalOverTimeWithReset"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual TotalOverTimeWithReset *clone() const
         { return new TotalOverTimeWithReset(args_count); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiTotalOverTimeWithReset.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiTotalOverTimeWithReset(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class AvgRunOverTimeWithReset
      ////////////////////////////////////////////////////////////
      class AvgRunOverTimeWithReset: public ResettableBase
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         AvgRunOverTimeWithReset(uint4 args_count_ = 0):
            ResettableBase(args_count_)
         { }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "AvgRunOverTimeWithReset"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual AvgRunOverTimeWithReset *clone() const
         { return new AvgRunOverTimeWithReset(args_count); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiAvgRunOverTimeWithReset.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiAvgRunOverTimeWithReset(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class MaxRunOverTimeWithReset
      ////////////////////////////////////////////////////////////
      class MaxRunOverTimeWithReset: public ResettableBase
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MaxRunOverTimeWithReset(uint4 args_count_ = 0):
            ResettableBase(args_count_)
         { }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MaxRunOverTimeWithReset"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MaxRunOverTimeWithReset *clone() const
         { return new MaxRunOverTimeWithReset(args_count); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMaxRunOverTimeWithReset.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMaxRunOverTimeWithReset(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };
      

      ////////////////////////////////////////////////////////////
      // class MinOverTimeWithReset
      ////////////////////////////////////////////////////////////
      class MinRunOverTimeWithReset: public ResettableBase
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MinRunOverTimeWithReset(uint4 args_count_ = 0):
            ResettableBase(args_count_)
         { }
         
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MinRunOverTimeWithReset"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MinRunOverTimeWithReset *clone() const
         { return new MinRunOverTimeWithReset(args_count); }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMinRunOverTimeWithReset.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMinRunOverTimeWithReset(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class MaxSpa
      ////////////////////////////////////////////////////////////
      class MaxSpa: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // args_count
         ////////////////////////////////////////////////////////////
         uint4 args_count;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MaxSpa():
            args_count(0)
         { }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MaxSpa"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MaxSpa *clone() const
         { return new MaxSpa; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMaxSpa.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMaxSpa(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // clear_args_count
         ////////////////////////////////////////////////////////////
         virtual void clear_args_count()
         { args_count = 1; }

         ////////////////////////////////////////////////////////////
         // increment_args_count
         ////////////////////////////////////////////////////////////
         virtual void increment_args_count()
         { ++args_count; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_max_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_max_arguments()
         { return 0xFFFFFFFF; }
         
         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { return L"number"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class MinSpa
      ////////////////////////////////////////////////////////////
      class MinSpa: public Function
      {
      private:
         ////////////////////////////////////////////////////////////
         // args_count
         ////////////////////////////////////////////////////////////
         uint4 args_count;

      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         MinSpa():
            args_count(0)
         { }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "MinSpa"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual MinSpa *clone() const
         { return new MinSpa; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiMinSpa.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiMinSpa(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // clear_args_count
         ////////////////////////////////////////////////////////////
         virtual void clear_args_count()
         { args_count = 1; }

         ////////////////////////////////////////////////////////////
         // increment_args_count
         ////////////////////////////////////////////////////////////
         virtual void increment_args_count()
         { ++args_count; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_max_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_max_arguments()
         { return 0xFFFFFFFF; }
         
         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { return L"number"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };

      
      ////////////////////////////////////////////////////////////
      // class Alias
      ////////////////////////////////////////////////////////////
      class Alias: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Alias"; }
         
         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Token *clone() const
         { return new Alias; }

         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"name";
               break;
               
            case 1:
               rtn = L"variable";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_alias
         ////////////////////////////////////////////////////////////
         virtual bool is_alias() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_alias; }
      };


      ////////////////////////////////////////////////////////////
      // class Ceiling
      ////////////////////////////////////////////////////////////
      class Ceiling: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "CEILING"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Ceiling *clone() const
         { return new Ceiling; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiCeiling.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiCeiling()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Floor
      ////////////////////////////////////////////////////////////
      class Floor: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "FLOOR"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Floor *clone() const
         { return new Floor; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiFloor.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiFloor()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Hex
      ////////////////////////////////////////////////////////////
      class Hex: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "Hex"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Hex *clone() const
         { return new Hex; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiHex.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiHex()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class HexToDec
      ////////////////////////////////////////////////////////////
      class HexToDec: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "HexToDec"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual HexToDec *clone() const
         { return new HexToDec; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiHexToDec.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiHexToDec()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"string";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_string_function; }
      };


      ////////////////////////////////////////////////////////////
      // class Round
      ////////////////////////////////////////////////////////////
      class Round: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ROUND"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual Round *clone() const
         { return new Round; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiRound.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiRound()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"decimalPlaces";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_math_function; }
      };

      
      ////////////////////////////////////////////////////////////
      // class StdDev
      ////////////////////////////////////////////////////////////
      class StdDev: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StdDev"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StdDev *clone() const
         { return new StdDev; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }

      private:
         ////////////////////////////////////////////////////////////
         // values
         ////////////////////////////////////////////////////////////
         typedef std::list<double> values_type;
         values_type values;

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiStdDev.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiStdDev()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"count";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }
      };
      

      ////////////////////////////////////////////////////////////
      // class StdDevOverTime
      ////////////////////////////////////////////////////////////
      class StdDevOverTime: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StdDevOverTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StdDevOverTime *clone() const
         { return new StdDevOverTime; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // reset_state
         ////////////////////////////////////////////////////////////
         virtual void reset_state()
         { values.clear(); }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      private:
         ////////////////////////////////////////////////////////////
         // values
         ////////////////////////////////////////////////////////////
         typedef std::multimap<Csi::LgrDate, double> values_type;
         values_type values;

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiStdDevOverTime.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiStdDevOverTime()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"number";
               break;

            case 1:
               rtn = L"valueTimestamp";
               break;

            case 2:
               rtn = L"interval";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }
      };


      ////////////////////////////////////////////////////////////
      // class StdDevOverTimeWithReset
      ////////////////////////////////////////////////////////////
      class StdDevOverTimeWithReset: public ResettableBase
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         StdDevOverTimeWithReset(uint4 args_count_ = 0):
            ResettableBase(args_count_)
         { }
         
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StdDevOverTimeWithReset"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StdDevOverTimeWithReset *clone() const
         { return new StdDevOverTimeWithReset(args_count); }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiStdDevOverTimeWithReset.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiStdDevOverTimeWithReset(" << args_count << ")"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_statistics_function; }
      };


      ////////////////////////////////////////////////////////////
      // class ValueSynch
      //
      // Defines an "aborting" function that acts as an Alias() would but,
      // rather than simply defining a synonym, this would replace all aliased
      // tokens with a SynchVariable object.  The SynchVariable class will
      // maintain a history of values and their timestamps and will choose the
      // best time stamp based upon the "oldest newest" time stamp of any other
      // SynchVariable objects in the expression.  
      ////////////////////////////////////////////////////////////
      class ValueSynch: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ValueSynch"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ValueSynch *clone() const
         { return new ValueSynch; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expr);

         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"name";
               break;

            case 1:
               rtn = L"variable";
               break;
               
            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_value_synch
         ////////////////////////////////////////////////////////////
         virtual bool is_value_synch() const
         { return true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_alias; }
      };


      ////////////////////////////////////////////////////////////
      // class StartAtRecordFunction
      ////////////////////////////////////////////////////////////
      class StartAtRecordFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StartAtRecord"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StartAtRecordFunction *clone() const
         { return new StartAtRecordFunction; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 3; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"fileMark";
               break;

            case 1:
               rtn = L"recordNo";
               break;

            case 2:
               rtn = L"orderOption";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            switch(index)
            {
            case 0:
            case 1:
               rtn = argument_type_number;
               break;

            case 2:
               rtn = argument_type_order_option;
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class StartAtTimeFunction
      ////////////////////////////////////////////////////////////
      class StartAtTimeFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StartAtTime"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StartAtTimeFunction *clone() const
         { return new StartAtTimeFunction; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"time";
               break;

            case 1:
               rtn = L"orderOption";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            switch(index)
            {
            case 0:
               rtn = argument_type_date;
               break;

            case 1:
               rtn = argument_type_order_option;
               break;
            } 
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class StartAtNewestFunction
      ////////////////////////////////////////////////////////////
      class StartAtNewestFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StartAtNewest"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StartAtNewestFunction *clone() const
         { return new StartAtNewestFunction; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"orderOption";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            if(index == 0)
               rtn = argument_type_order_option;
            return rtn;
         } // get_argument_type

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class StartAfterNewestFunction
      ////////////////////////////////////////////////////////////
      class StartAfterNewestFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StartAfterNewest"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StartAfterNewestFunction *clone() const
         { return new StartAfterNewestFunction; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"orderOption";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            if(index == 0)
               rtn = argument_type_order_option;
            return rtn;
         } // get_argument_type

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class StartRelativeToNewestFunction
      ////////////////////////////////////////////////////////////
      class StartRelativeToNewestFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StartRelativeToNewest"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StartRelativeToNewestFunction *clone() const
         { return new StartRelativeToNewestFunction; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"interval";
               break;

            case 1:
               rtn = L"orderOption";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            switch(index)
            {
            case 0:
               rtn = argument_type_number;
               break;

            case 1:
               rtn = argument_type_order_option;
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class StartAtOffsetFromNewestFunction
      ////////////////////////////////////////////////////////////
      class StartAtOffsetFromNewestFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "StartAtOffsetFromNewest"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual StartAtOffsetFromNewestFunction *clone() const
         { return new StartAtOffsetFromNewestFunction; }


         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 2; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"count";
               break;

            case 1:
               rtn = L"orderOption";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            switch(index)
            {
            case 0:
               rtn = argument_type_number;
               break;

            case 1:
               rtn = argument_type_order_option;
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class ReportOffsetFunction
      ////////////////////////////////////////////////////////////
      class ReportOffsetFunction: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // abort_after_eval
         ////////////////////////////////////////////////////////////
         virtual bool abort_after_eval()
         { return true; }

         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "ReportOffset"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual ReportOffsetFunction *clone() const
         { return new ReportOffsetFunction; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         {
            wchar_t const *rtn(0);
            switch(index)
            {
            case 0:
               rtn = L"interval";
               break;

            default:
               throw std::invalid_argument("invalid argument index");
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_argument_type
         ////////////////////////////////////////////////////////////
         virtual argument_type_code get_argument_type(uint4 index)
         {
            argument_type_code rtn(argument_type_unknown);
            switch(index)
            {
            case 0:
               rtn = argument_type_number;
               break;
            }
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // is_start_condition
         ////////////////////////////////////////////////////////////
         virtual bool is_start_condition() const
         { return  true; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_start_option; }
      };


      ////////////////////////////////////////////////////////////
      // class LocalToGmt
      ////////////////////////////////////////////////////////////
      class LocalToGmt: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "LocalToGmt"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual LocalToGmt *clone() const
         { return new LocalToGmt; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return false; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiLocalToGmt.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiLocalToGmt()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { return L"valueTimestamp"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };


      ////////////////////////////////////////////////////////////
      // class GmtToLocal
      ////////////////////////////////////////////////////////////
      class GmtToLocal: public Function
      {
      public:
         ////////////////////////////////////////////////////////////
         // eval
         ////////////////////////////////////////////////////////////
         virtual void eval(token_stack_type &stack, ExpressionHandler *expression);

         ////////////////////////////////////////////////////////////
         // format
         ////////////////////////////////////////////////////////////
         virtual void format(std::ostream &out) const
         { out << "GmtToLocal"; }

         ////////////////////////////////////////////////////////////
         // clone
         ////////////////////////////////////////////////////////////
         virtual GmtToLocal *clone() const
         { return new GmtToLocal; }

         ////////////////////////////////////////////////////////////
         // has_state
         ////////////////////////////////////////////////////////////
         virtual bool has_state() const
         { return false; }

         ////////////////////////////////////////////////////////////
         // get_js_resource
         ////////////////////////////////////////////////////////////
         virtual StrAsc get_js_resource() const
         { return "CsiGmtToLocal.js"; }

         ////////////////////////////////////////////////////////////
         // format_js
         ////////////////////////////////////////////////////////////
         virtual void format_js(std::ostream &out)
         { out << "new CsiGmtToLocal()"; }

         ////////////////////////////////////////////////////////////
         // get_min_arguments
         ////////////////////////////////////////////////////////////
         virtual uint4 get_min_arguments()
         { return 1; }

         ////////////////////////////////////////////////////////////
         // get_argument_name
         ////////////////////////////////////////////////////////////
         virtual wchar_t const *get_argument_name(uint4 index)
         { return L"valueTimestamp"; }

         ////////////////////////////////////////////////////////////
         // get_category
         ////////////////////////////////////////////////////////////
         virtual category_type get_category() const
         { return category_time_function; }
      };
   };
};


#endif //csi_expression_tokentypes_h
