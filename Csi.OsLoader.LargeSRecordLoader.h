/* Csi.OsLoader.LargeSRecordLoader.h

   Copyright (C) 2008, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Monday 02 June 2008
   Last Change: Thursday 27 January 2011
   Last Commit: $Date: 2011-01-27 12:51:49 -0600 (Thu, 27 Jan 2011) $ 
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Csi_OsLoader_LargeSRecordLoader_h
#define Csi_OsLoader_LargeSRecordLoader_h

#include "Csi.OsLoader.OsLoaderBase.h"
#include "Csi.PakBus.LowLevelDecoder.h"
#include "Csi.DevConfig.LibraryManager.h"
#include "OneShot.h"
#include "StrAsc.h"
#include "Csi.ByteQueue.h"
#include <list>


namespace Csi
{
   namespace OsLoader
   {
      ////////////////////////////////////////////////////////////
      // struct DeviceTypeMap
      ////////////////////////////////////////////////////////////
      struct DeviceTypeMap
      {
         uint4 address;
         StrAsc device_type;
         uint4 sig_address;
      };

      
      ////////////////////////////////////////////////////////////
      // class LargeSRecordLoader
      //
      // Defines an object the implements the SRecord operating system download
      // protocol as used in the RF400, MD485, and CR200.
      ////////////////////////////////////////////////////////////
      class LargeSRecordLoader:
         public OsLoaderBase,
         public OneShotClient
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         typedef SharedPtr<OneShot> timer_handle;
         LargeSRecordLoader(
            timer_handle &timer_,
            StrAsc const &device_type_ = "",
            Csi::DevConfig::LibraryManager *manager = 0);

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~LargeSRecordLoader();

         ////////////////////////////////////////////////////////////
         // get_file_extension
         ////////////////////////////////////////////////////////////
         virtual char const *get_file_extension()
         {
            char const *rtn(OsLoaderBase::get_file_extension());
            if(*rtn == 0)
               rtn = "*.a43";
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // open_and_validate
         ////////////////////////////////////////////////////////////
         virtual void open_and_validate(
            char const *os_file_name);

         // @group: definitions needed to make this class act as a container for the s-records

         ////////////////////////////////////////////////////////////
         // begin
         ////////////////////////////////////////////////////////////
         typedef StrAsc value_type;
         typedef std::list<value_type> records_type;
         typedef records_type::const_iterator const_iterator;
         typedef records_type::iterator iterator;
         const_iterator begin() const
         { return records.begin(); }
         iterator begin()
         { return records.begin(); }

         ////////////////////////////////////////////////////////////
         // end
         ////////////////////////////////////////////////////////////
         const_iterator end() const
         { return records.end(); }
         iterator end()
         { return records.end(); }

         ////////////////////////////////////////////////////////////
         // empty
         ////////////////////////////////////////////////////////////
         bool empty() const
         { return records.empty(); }

         ////////////////////////////////////////////////////////////
         // size
         ////////////////////////////////////////////////////////////
         typedef records_type::size_type size_type;
         size_type size() const
         { return records.size(); }
         
         // @endgroup
         
         ////////////////////////////////////////////////////////////
         // start_send
         ////////////////////////////////////////////////////////////
         virtual void start_send(
            driver_handle driver,
            EventReceiver *client);

         ////////////////////////////////////////////////////////////
         // cancel_send
         ////////////////////////////////////////////////////////////
         virtual void cancel_send();

         ////////////////////////////////////////////////////////////
         // on_receive
         ////////////////////////////////////////////////////////////
         virtual void on_receive(
            OsLoaderDriver *driver,
            void const *buff,
            uint4 buff_len);

      protected:
         ////////////////////////////////////////////////////////////
         // on_complete
         ////////////////////////////////////////////////////////////
         virtual void on_complete(
            char const *message,
            bool succeeded);

         ////////////////////////////////////////////////////////////
         // send_status
         ////////////////////////////////////////////////////////////
         void send_status(char const *message);

         ////////////////////////////////////////////////////////////
         // onOneShotFired
         ////////////////////////////////////////////////////////////
         virtual void onOneShotFired(uint4 event_id);

      protected:
         ////////////////////////////////////////////////////////////
         // on_error
         ////////////////////////////////////////////////////////////
         void on_error(char const *message);

         ////////////////////////////////////////////////////////////
         // start_send_device_type
         ////////////////////////////////////////////////////////////
         void start_send_device_type();
         
         ////////////////////////////////////////////////////////////
         // send_next_srecord
         ////////////////////////////////////////////////////////////
         void send_next_srecord();

         ////////////////////////////////////////////////////////////
         // check_for_device_type
         ////////////////////////////////////////////////////////////
         void check_for_device_type();

         ////////////////////////////////////////////////////////////
         // check_for_flash_erase_ack
         ////////////////////////////////////////////////////////////
         void check_for_flash_erase_ack();

         ////////////////////////////////////////////////////////////
         // check_for_ack
         ////////////////////////////////////////////////////////////
         void check_for_ack();

         ////////////////////////////////////////////////////////////
         // send_reset_command
         ////////////////////////////////////////////////////////////
         void send_reset_command();
         
         ////////////////////////////////////////////////////////////
         // check_for_reset_ack
         ////////////////////////////////////////////////////////////
         void check_for_reset_ack(
            byte const *buff, uint4 buff_len);

         ////////////////////////////////////////////////////////////
         // validate_device_type
         ////////////////////////////////////////////////////////////
         void validate_device_type(
            uint4 address, char const *data, uint4 data_len);

      protected:
         ////////////////////////////////////////////////////////////
         // send_devconfig_reset
         ////////////////////////////////////////////////////////////
         bool send_devconfig_reset;
         
         ////////////////////////////////////////////////////////////
         // os_file_name
         ////////////////////////////////////////////////////////////
         StrAsc os_file_name;

         ////////////////////////////////////////////////////////////
         // records
         //
         // Contains all of the SRecords that were read from the file. 
         //////////////////////////////////////////////////////////// 
         records_type records;

         ////////////////////////////////////////////////////////////
         // timer
         ////////////////////////////////////////////////////////////
         timer_handle timer;

         ////////////////////////////////////////////////////////////
         // file_sig
         ////////////////////////////////////////////////////////////
         uint2 file_sig;

         ////////////////////////////////////////////////////////////
         // file_size_bytes
         ////////////////////////////////////////////////////////////
         uint4 file_size_bytes;

         ////////////////////////////////////////////////////////////
         // bytes_sent
         ////////////////////////////////////////////////////////////
         uint4 bytes_sent;

         ////////////////////////////////////////////////////////////
         // device_type
         ////////////////////////////////////////////////////////////
         StrAsc device_type;

         ////////////////////////////////////////////////////////////
         // confirm_device_type
         ////////////////////////////////////////////////////////////
         bool confirm_device_type;

         ////////////////////////////////////////////////////////////
         // needs_flash_reset
         ////////////////////////////////////////////////////////////
         bool needs_flash_reset;

         ////////////////////////////////////////////////////////////
         // device_sig_address
         ////////////////////////////////////////////////////////////
         uint4 device_sig_address;

         ////////////////////////////////////////////////////////////
         // state
         ////////////////////////////////////////////////////////////
         enum state_type
         {
            state_standby,
            state_open,
            state_send_reset,
            state_getting_device_type,
            state_wait_for_flash_erase,
            state_sending,
            state_error
         } state;

         ////////////////////////////////////////////////////////////
         // get_device_type_id
         //
         // Identifies the timer that we will use to wait for the device type
         // to be echoed.
         ////////////////////////////////////////////////////////////
         uint4 get_device_type_id; 

         ////////////////////////////////////////////////////////////
         // get_ack_id
         ////////////////////////////////////////////////////////////
         uint4 get_ack_id;

         ////////////////////////////////////////////////////////////
         // retry_count
         ////////////////////////////////////////////////////////////
         uint4 retry_count;

         ////////////////////////////////////////////////////////////
         // receive_buffer
         ////////////////////////////////////////////////////////////
         ByteQueue receive_buffer;

         ////////////////////////////////////////////////////////////
         // records_sent
         ////////////////////////////////////////////////////////////
         uint4 records_sent;

         ////////////////////////////////////////////////////////////
         // pakbus_decoder
         //
         // Used to interpret the response from the device while waiting for a
         // response from the reset transaction. 
         ////////////////////////////////////////////////////////////
         Csi::PakBus::LowLevelDecoder pakbus_decoder;

         ////////////////////////////////////////////////////////////
         // reset_id
         ////////////////////////////////////////////////////////////
         uint4 reset_id;

         ////////////////////////////////////////////////////////////
         // device_types
         ////////////////////////////////////////////////////////////
         typedef std::list<DeviceTypeMap> device_types_type;
         device_types_type device_types;
      };
   };
};


#endif
