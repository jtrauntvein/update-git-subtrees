/* Csi.ByteQueueStream.h

   Copyright (C) 2006, 2010 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 07 February 2006
   Last Change: Thursday 28 October 2010
   Last Commit: $Date: 2016-05-03 16:18:03 -0600 (Tue, 03 May 2016) $ 
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Csi_ByteQueueStream_h
#define Csi_ByteQueueStream_h

#include "Csi.ByteQueue.h"
#include <iostream>


namespace Csi
{
   //@group class forward declarations
   class OByteQueueStream;
   class IByteQueueStream;
   //@endgroup

   
   ////////////////////////////////////////////////////////////
   // ByteQueueStreamBuffer
   ////////////////////////////////////////////////////////////
   class ByteQueueStreamBuf: public std::streambuf
   {
   private:
      ////////////////////////////////////////////////////////////
      // queue
      ////////////////////////////////////////////////////////////
      ByteQueue *queue;

      ////////////////////////////////////////////////////////////
      // rx_buff
      ////////////////////////////////////////////////////////////
      char rx_buff[512];

      ////////////////////////////////////////////////////////////
      // rx_buff_len
      ////////////////////////////////////////////////////////////
      uint4 rx_buff_len;

      friend class OByteQueueStream;
      friend class IByteQueueStream;

   public:
      ////////////////////////////////////////////////////////////
      // constructor
      ////////////////////////////////////////////////////////////
      ByteQueueStreamBuf(ByteQueue *queue_):
         queue(queue_),
         rx_buff_len(0)
      { setg(rx_buff, rx_buff, rx_buff); }

      ////////////////////////////////////////////////////////////
      // overflow
      ////////////////////////////////////////////////////////////
      virtual int_type overflow(int_type ch)
      {
         queue->push(&ch,1);
         return ch;
      }

      ////////////////////////////////////////////////////////////
      // xsputn
      ////////////////////////////////////////////////////////////
      virtual std::streamsize xsputn(
         char const *buff,
         std::streamsize buff_len)
      {
         queue->push(buff, static_cast<uint4>(buff_len));
         return buff_len;
      }

      ////////////////////////////////////////////////////////////
      // underflow
      ////////////////////////////////////////////////////////////
      virtual int_type underflow()
      {
         byte rtn = EOF;
         if(queue->size() > 0)
         {
            rx_buff_len = queue->pop(rx_buff, sizeof(rx_buff));
            setg(rx_buff, rx_buff, rx_buff + rx_buff_len);
            rtn = *rx_buff;
         }
         return rtn;
      }
   };


   ////////////////////////////////////////////////////////////
   // class OByteQueueStream
   ////////////////////////////////////////////////////////////
   class OByteQueueStream: public std::ostream
   {
   protected:
      ////////////////////////////////////////////////////////////
      // buffer
      ////////////////////////////////////////////////////////////
      ByteQueueStreamBuf buffer;
      
   public:
      ////////////////////////////////////////////////////////////
      // constructor
      ////////////////////////////////////////////////////////////
      OByteQueueStream(ByteQueue *queue):
         buffer(queue),
         std::ostream(&buffer)
      { }

      ////////////////////////////////////////////////////////////
      // str
      ////////////////////////////////////////////////////////////
      ByteQueue *str()
      { return buffer.queue; }

      ////////////////////////////////////////////////////////////
      // str (with assignment)
      ////////////////////////////////////////////////////////////
      ByteQueue *str(char const *s)
      {
         buffer.queue->pop(buffer.queue->size());
         buffer.queue->push(s,(uint4)strlen(s));
         return buffer.queue;
      }
   };


   ////////////////////////////////////////////////////////////
   // class IByteQueueStream
   ////////////////////////////////////////////////////////////
   class IByteQueueStream: public std::istream
   {
   protected:
      ////////////////////////////////////////////////////////////
      // buffer
      ////////////////////////////////////////////////////////////
      ByteQueueStreamBuf buffer;

   public:
      ////////////////////////////////////////////////////////////
      // constructor
      ////////////////////////////////////////////////////////////
      IByteQueueStream(ByteQueue *queue):
         buffer(queue),
         std::istream(&buffer)
      { }
   };
};


#endif
