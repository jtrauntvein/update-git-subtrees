/* Csi.WorkerThread.h

   Copyright (C) 2009, 2013 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Friday 20 November 2009
   Last Change: Friday 24 May 2013
   Last Commit: $Date: 2013-05-24 09:36:42 -0600 (Fri, 24 May 2013) $
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Csi_WorkerThread_h
#define Csi_WorkerThread_h

#include "Csi.Thread.h"
#include "Csi.Events.h"
#include "Csi.CriticalSection.h"
#include "Csi.Condition.h"
#include <list>


namespace Csi
{
   ////////////////////////////////////////////////////////////
   // class WorkerThreadCommand
   //
   // Declares a base class for an object that can be executed in the context
   // of a worker thread.  
   ////////////////////////////////////////////////////////////
   class WorkerThread;
   class WorkerThreadCommand
   {
   public:
      ////////////////////////////////////////////////////////////
      // command_type
      ////////////////////////////////////////////////////////////
      uint4 const command_type;

      ////////////////////////////////////////////////////////////
      // client
      ////////////////////////////////////////////////////////////
      EventReceiver *client;
      
      ////////////////////////////////////////////////////////////
      // constructor
      ////////////////////////////////////////////////////////////
      WorkerThreadCommand(
         uint4 command_type_, EventReceiver *client_):
         command_type(command_type_),
         client(client_)
      { }

      ////////////////////////////////////////////////////////////
      // destructor
      ////////////////////////////////////////////////////////////
      virtual ~WorkerThreadCommand()
      { }

      ////////////////////////////////////////////////////////////
      // execute
      ////////////////////////////////////////////////////////////
      virtual void execute(WorkerThread *thread) = 0;

      ////////////////////////////////////////////////////////////
      // abort
      //
      // can be overloaded to abort the command before rather than letting it
      // run to completion. 
      ////////////////////////////////////////////////////////////
      virtual void abort()
      { }
   };


   ////////////////////////////////////////////////////////////
   // class EventWorkerThreadCommandComplete
   ////////////////////////////////////////////////////////////
   class EventWorkerThreadCommandComplete: public Event
   {
   public:
      ////////////////////////////////////////////////////////////
      // event_id
      ////////////////////////////////////////////////////////////
      static uint4 const event_id;

      ////////////////////////////////////////////////////////////
      // command
      ////////////////////////////////////////////////////////////
      typedef SharedPtr<WorkerThreadCommand> command_handle;
      command_handle command;

      ////////////////////////////////////////////////////////////
      // cpost
      ////////////////////////////////////////////////////////////
      static void cpost(command_handle &command)
      {
         Event *event = new EventWorkerThreadCommandComplete(command);
         event->post();
      }

   private:
      ////////////////////////////////////////////////////////////
      // constructor
      ////////////////////////////////////////////////////////////
      EventWorkerThreadCommandComplete(command_handle &command_):
         Event(event_id, command_->client),
         command(command_)
      { }
   };

   
   ////////////////////////////////////////////////////////////
   // class WorkerThread
   ////////////////////////////////////////////////////////////
   class WorkerThread: public Thread
   {
   public:
      ////////////////////////////////////////////////////////////
      // constructor
      ////////////////////////////////////////////////////////////
      WorkerThread();

      ////////////////////////////////////////////////////////////
      // destructor
      ////////////////////////////////////////////////////////////
      virtual ~WorkerThread()
      { wait_for_end(); }

      ////////////////////////////////////////////////////////////
      // start
      ////////////////////////////////////////////////////////////
      virtual void start();

      ////////////////////////////////////////////////////////////
      // wait_for_end
      ////////////////////////////////////////////////////////////
      virtual void wait_for_end();

      ////////////////////////////////////////////////////////////
      // add_command
      ////////////////////////////////////////////////////////////
      typedef SharedPtr<WorkerThreadCommand> value_type;
      void add_command(value_type command);

   protected:
      ////////////////////////////////////////////////////////////
      // execute
      ////////////////////////////////////////////////////////////
      virtual void execute();

   private:
      ////////////////////////////////////////////////////////////
      // condition
      ////////////////////////////////////////////////////////////
      Condition condition;

      ////////////////////////////////////////////////////////////
      // commands
      ////////////////////////////////////////////////////////////
      CriticalSection commands_protector;
      typedef std::list<value_type> commands_type;
      commands_type commands;

      ////////////////////////////////////////////////////////////
      // should_quit
      ////////////////////////////////////////////////////////////
      bool should_quit;
   }; 
};


#endif
