/* Csi.Tob2.DataFile.h

   Copyright (C) 2005, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Thursday 09 June 2005
   Last Change: Wednesday 09 February 2011
   Last Commit: $Date: 2011-02-09 16:26:23 -0600 (Wed, 09 Feb 2011) $ 
   Last Changed by: $Author: jon $

*/

#ifndef Csi_Tob2_DataFile_h
#define Csi_Tob2_DataFile_h

#include "Csi.Tob2.Frame.h"
#include "CsiTypes.h"
#include "StrAsc.h"
#include "Csi.InstanceValidator.h"
#include <vector>


namespace Csi
{
   namespace Tob2
   {
      //@group class forward declarations
      class DataFile;
      //@endgroup

      
      ////////////////////////////////////////////////////////////
      // class Field
      //
      // Defines an object that represents the meta-data for a field in a
      // TOB2/TOB3 file.  This information is initialised when the header is
      // read in class DataFile.  
      ////////////////////////////////////////////////////////////
      class Field
      {
      private:
         ////////////////////////////////////////////////////////////
         // name
         ////////////////////////////////////////////////////////////
         StrAsc name;

         ////////////////////////////////////////////////////////////
         // units
         ////////////////////////////////////////////////////////////
         StrAsc units;

         ////////////////////////////////////////////////////////////
         // processing
         ////////////////////////////////////////////////////////////
         StrAsc processing;

         ////////////////////////////////////////////////////////////
         // data_type
         ////////////////////////////////////////////////////////////
         CsiLgrTypeCode data_type;

         ////////////////////////////////////////////////////////////
         // string_len
         ////////////////////////////////////////////////////////////
         uint4 string_len;

         friend class DataFile;
         
      public:
         ////////////////////////////////////////////////////////////
         // constructor (default)
         ////////////////////////////////////////////////////////////
         Field():
            data_type(LgrUnknown),
            string_len(0)
         { }

         ////////////////////////////////////////////////////////////
         // copy constructor
         ////////////////////////////////////////////////////////////
         Field(Field const &other):
            name(other.name),
            units(other.units),
            processing(other.processing),
            data_type(other.data_type),
            string_len(other.string_len)
         { }

         ////////////////////////////////////////////////////////////
         // copy operator
         ////////////////////////////////////////////////////////////
         Field &operator =(Field const &other)
         {
            name = other.name;
            units = other.units;
            processing = other.processing;
            data_type = other.data_type;
            string_len = other.string_len;
            return *this;
         }

         ////////////////////////////////////////////////////////////
         // get_name
         ////////////////////////////////////////////////////////////
         StrAsc const &get_name() const
         { return name; }

         ////////////////////////////////////////////////////////////
         // get_units
         ////////////////////////////////////////////////////////////
         StrAsc const &get_units() const
         { return units; }

         ////////////////////////////////////////////////////////////
         // get_processing
         ////////////////////////////////////////////////////////////
         StrAsc get_processing() const
         { return processing; }

         ////////////////////////////////////////////////////////////
         // get_data_type
         ////////////////////////////////////////////////////////////
         CsiLgrTypeCode get_data_type() const
         { return data_type; }

         ////////////////////////////////////////////////////////////
         // get_string_len
         ////////////////////////////////////////////////////////////
         uint4 get_string_len() const
         { return string_len; }

         ////////////////////////////////////////////////////////////
         // get_field_size
         //
         // Returns the size in bytes that the field will be expected to occupy
         // in the data file.  This value is a combination between the data
         // type and the string length value.
         ////////////////////////////////////////////////////////////
         uint4 get_field_size() const;
      };


      ////////////////////////////////////////////////////////////
      // class ExcEndOfFile
      //
      // Defines the class of exception that will be thrown when the
      // application attempts to read a frame past the end of the file. 
      ////////////////////////////////////////////////////////////
      class ExcEndOfFile: public std::exception
      {
      public:
         ////////////////////////////////////////////////////////////
         // what
         ////////////////////////////////////////////////////////////
         virtual char const *what() const throw ()
         { return "Attempt to read past the end of the file"; }
      };


      ////////////////////////////////////////////////////////////
      // class ExcInvalidFrame
      //
      // Defines the class of exception that will be thrown when the
      // application attempts to read as frame that is invalid. 
      ////////////////////////////////////////////////////////////
      class ExcInvalidFrame: public std::exception
      {
      public:
         ////////////////////////////////////////////////////////////
         // what
         ////////////////////////////////////////////////////////////
         virtual char const *what() const throw ()
         { return "Attempt to read an invalid frame"; }
      };
      
      
      ////////////////////////////////////////////////////////////
      // class DataFile
      //
      // Defines an object that encapsulates a TOB2/TOB3 data file and makes
      // the contents of that file available to the application in terms of its
      // frame content as well as header information.  
      ////////////////////////////////////////////////////////////
      class DataFile: public InstanceValidator
      {
      private:
         ////////////////////////////////////////////////////////////
         // file_type
         //
         // Specifies the type of the file as identified in the header
         //////////////////////////////////////////////////////////// 
      public:
         enum file_type_code
         {
            type_tob1,
            type_tob2,
            type_tob3
         };
      private:
         file_type_code file_type;

         ////////////////////////////////////////////////////////////
         // station_name
         ////////////////////////////////////////////////////////////
         StrAsc station_name;

         ////////////////////////////////////////////////////////////
         // model_no
         ////////////////////////////////////////////////////////////
         StrAsc model_no;

         ////////////////////////////////////////////////////////////
         // serial_no
         ////////////////////////////////////////////////////////////
         StrAsc serial_no;

         ////////////////////////////////////////////////////////////
         // os_version
         ////////////////////////////////////////////////////////////
         StrAsc os_version;

         ////////////////////////////////////////////////////////////
         // dld_name
         ////////////////////////////////////////////////////////////
         StrAsc dld_name;

         ////////////////////////////////////////////////////////////
         // dld_signature
         ////////////////////////////////////////////////////////////
         uint2 dld_signature;

         ////////////////////////////////////////////////////////////
         // create_time
         ////////////////////////////////////////////////////////////
         StrAsc create_time;

         ////////////////////////////////////////////////////////////
         // table_name
         ////////////////////////////////////////////////////////////
         StrAsc table_name;

         ////////////////////////////////////////////////////////////
         // record_interval_string
         ////////////////////////////////////////////////////////////
         StrAsc record_interval_string;
         
         ////////////////////////////////////////////////////////////
         // record_interval
         ////////////////////////////////////////////////////////////
         int8 record_interval;

         ////////////////////////////////////////////////////////////
         // frame_size
         ////////////////////////////////////////////////////////////
         uint4 frame_size;

         ////////////////////////////////////////////////////////////
         // intended_table_size
         ////////////////////////////////////////////////////////////
         uint4 intended_table_size;

         ////////////////////////////////////////////////////////////
         // validation_stamp
         ////////////////////////////////////////////////////////////
         uint2 validation_stamp;

         ////////////////////////////////////////////////////////////
         // time_resolution
         //
         // This string is read from the header and is critical in specifying
         // the sub-second time resolution units used in the file.
         ////////////////////////////////////////////////////////////
         StrAsc time_resolution;

         ////////////////////////////////////////////////////////////
         // subsecs_factor
         //
         // This value, initialised by parsing the time_resolution header
         // field, specifies the value by which the sub-seconds time stamp
         // field read from frames must be multiplied by in order to obtain
         // nano-seconds. 
         ////////////////////////////////////////////////////////////
         uint4 subsecs_factor;

         ////////////////////////////////////////////////////////////
         // ring_record_no
         ////////////////////////////////////////////////////////////
         uint4 ring_record_no;

         ////////////////////////////////////////////////////////////
         // card_removal_time
         ////////////////////////////////////////////////////////////
         uint4 card_removal_time;

         ////////////////////////////////////////////////////////////
         // file
         ////////////////////////////////////////////////////////////
         FILE *file;

         ////////////////////////////////////////////////////////////
         // header_length
         //
         // specifies the length of the header in the file. 
         ////////////////////////////////////////////////////////////
         uint4 header_length;

         ////////////////////////////////////////////////////////////
         // read_buff
         //
         // This member is used to read the frames from the file.  It is stored
         // as a member for efficiency's sake because it would otherwise have
         // to be allocated every time that we needed to read. 
         ////////////////////////////////////////////////////////////
         StrBin read_buff;

         ////////////////////////////////////////////////////////////
         // fields
         ////////////////////////////////////////////////////////////
      public:
         typedef std::vector<Field> fields_type;
      private:
         fields_type fields;

         ////////////////////////////////////////////////////////////
         // cached_record_size
         //
         // Caches the calculated value of the record size.  This value could
         // be calculated each time but that requires iterating through the
         // fields and looking up the sizes for each field type.  This member
         // is initialised the first time that get_record_size() is called and
         // is used to return the record size each time get_record_size() is
         // called. 
         ////////////////////////////////////////////////////////////
         uint4 cached_record_size;

         ////////////////////////////////////////////////////////////
         // tob1_secs_pos
         ////////////////////////////////////////////////////////////
         uint4 tob1_secs_pos;

         ////////////////////////////////////////////////////////////
         // tob1_nsecs_pos
         ////////////////////////////////////////////////////////////
         uint4 tob1_nsecs_pos;

         ////////////////////////////////////////////////////////////
         // tob1_record_no_pos
         ////////////////////////////////////////////////////////////
         uint4 tob1_record_no_pos;

         ////////////////////////////////////////////////////////////
         // file_name
         ////////////////////////////////////////////////////////////
         StrAsc file_name;

         ////////////////////////////////////////////////////////////
         // is_sleeping
         ////////////////////////////////////////////////////////////
         bool is_sleeping;

         ////////////////////////////////////////////////////////////
         // header_sig
         ////////////////////////////////////////////////////////////
         uint2 header_sig;

         ////////////////////////////////////////////////////////////
         // hibernate_pos
         ////////////////////////////////////////////////////////////
         int8 hibernate_pos;

         ////////////////////////////////////////////////////////////
         // data_sig
         ////////////////////////////////////////////////////////////
         uint2 data_sig;

         ////////////////////////////////////////////////////////////
         // data_len
         ////////////////////////////////////////////////////////////
         int8 data_len;
         
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         //
         // Attempts to open the specified file and read its header.  If all
         // goes well, the file will be left in an open state and the header
         // information can be queried using the various get_xxx() methods.
         // If the file cannot be opened or the header cannot be parsed, an
         // exception derived from class std::exception will be thrown. 
         ////////////////////////////////////////////////////////////
         DataFile(char const *file_name);

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         ~DataFile();

         ////////////////////////////////////////////////////////////
         // hibernate
         ////////////////////////////////////////////////////////////
         void hibernate();

         ////////////////////////////////////////////////////////////
         // wake_up
         ////////////////////////////////////////////////////////////
         virtual bool wake_up(bool &all_data_overwritten);
         
         ////////////////////////////////////////////////////////////
         // get_header
         //
         // Reads the entire header into the supplied string buffer.  The
         // return value will be the beginning contents of the buffer. 
         ////////////////////////////////////////////////////////////
         char const *get_header(StrAsc &buff);

         ////////////////////////////////////////////////////////////
         // get_header_length
         ////////////////////////////////////////////////////////////
         uint4 get_header_length() const
         { return header_length; }

         ////////////////////////////////////////////////////////////
         // get_file_type
         ////////////////////////////////////////////////////////////
         file_type_code get_file_type() const
         { return file_type; }

         ////////////////////////////////////////////////////////////
         // get_station_name
         ////////////////////////////////////////////////////////////
         StrAsc const &get_station_name() const
         { return station_name; }

         ////////////////////////////////////////////////////////////
         // get_model_no
         ////////////////////////////////////////////////////////////
         StrAsc const &get_model_no() const
         { return model_no; }

         ////////////////////////////////////////////////////////////
         // get_serial_no
         ////////////////////////////////////////////////////////////
         StrAsc const &get_serial_no() const
         { return serial_no; }

         ////////////////////////////////////////////////////////////
         // get_os_version
         ////////////////////////////////////////////////////////////
         StrAsc const &get_os_version() const
         { return os_version; }

         ////////////////////////////////////////////////////////////
         // get_dld_name
         ////////////////////////////////////////////////////////////
         StrAsc const &get_dld_name() const
         { return dld_name; }

         ////////////////////////////////////////////////////////////
         // get_dld_signature
         ////////////////////////////////////////////////////////////
         uint2 get_dld_signature() const
         { return dld_signature; }

         ////////////////////////////////////////////////////////////
         // get_create_time
         ////////////////////////////////////////////////////////////
         StrAsc const &get_create_time() const
         { return create_time; }

         ////////////////////////////////////////////////////////////
         // get_table_name
         ////////////////////////////////////////////////////////////
         StrAsc const &get_table_name() const
         { return table_name; }

         ////////////////////////////////////////////////////////////
         // get_record_interval_string
         ////////////////////////////////////////////////////////////
         StrAsc const &get_record_interval_string() const
         { return record_interval_string; }
         
         ////////////////////////////////////////////////////////////
         // get_record_interval
         ////////////////////////////////////////////////////////////
         int8 get_record_interval() const
         { return record_interval; }

         ////////////////////////////////////////////////////////////
         // get_intended_table_size
         ////////////////////////////////////////////////////////////
         uint4 get_intended_table_size() const
         { return intended_table_size; }

         ////////////////////////////////////////////////////////////
         // get_validation_stamp
         ////////////////////////////////////////////////////////////
         uint2 get_validation_stamp() const
         { return validation_stamp; }

         ////////////////////////////////////////////////////////////
         // get_time_resolution
         ////////////////////////////////////////////////////////////
         StrAsc const &get_time_resolution() const
         { return time_resolution; }

         ////////////////////////////////////////////////////////////
         // get_subsecs_factor
         ////////////////////////////////////////////////////////////
         uint4 get_subsecs_factor() const
         { return subsecs_factor; }

         ////////////////////////////////////////////////////////////
         // get_frame_size
         ////////////////////////////////////////////////////////////
         uint4 get_frame_size() const
         { return frame_size; }

         ////////////////////////////////////////////////////////////
         // get_ring_record_no
         ////////////////////////////////////////////////////////////
         uint4 get_ring_record_no() const
         { return ring_record_no; }

         ////////////////////////////////////////////////////////////
         // get_card_removal_time
         ////////////////////////////////////////////////////////////
         uint4 get_card_removal_time() const
         { return card_removal_time; }

         ////////////////////////////////////////////////////////////
         // get_record_size
         ////////////////////////////////////////////////////////////
         uint4 get_record_size();

         ////////////////////////////////////////////////////////////
         // get_frames_count
         //
         // Calculates the total number of frames that the file can contain.
         // The number of valid frames in the file may be less than this number
         // but this will be the maximum value that can be specified when
         // seek_to_frame() is called. 
         ////////////////////////////////////////////////////////////
         int8 get_frames_count();

         ////////////////////////////////////////////////////////////
         // seek_to_frame
         //
         // Seeks the file pointer to the specified frame number (not file
         // offset) so that this frame will be the next one read in when
         // read_next_frame() is called.
         ////////////////////////////////////////////////////////////
         void seek_to_frame(int8 frame_no);
         
         ////////////////////////////////////////////////////////////
         // seek_to_oldest
         //
         // Positions the file pointer so that the next frame read will be the
         // oldest frame in the file.    The return value will be the frame
         // that was selected. 
         ////////////////////////////////////////////////////////////
         int8 seek_to_oldest();

         ////////////////////////////////////////////////////////////
         // seek_to_newest
         //
         // Positions the file pointer so that the next frame read will be the
         // newest frame in the file.  The return value will be the frame
         // number that was selected.
         ////////////////////////////////////////////////////////////
         int8 seek_to_newest();

         ////////////////////////////////////////////////////////////
         // read_next_frame
         //
         // Reads the next frame from the file from the current position. If
         // the frame cannot be read, a std::exception derived object will be
         // thrown. 
         ////////////////////////////////////////////////////////////
         void read_next_frame(Frame &dest);

         ////////////////////////////////////////////////////////////
         // do_resynch
         //
         // Attempts to resynchronise the frames assuming that a frame has been
         // only partially written and that there may be valid frames someplace
         // within.  This method will do the following:
         //
         //   1 - seek to the frame boundary above the current read location
         //   (this will be skipped if the current location is within one frame
         //   of the beginning).
         //
         //   2 - search forward for the file validation stamp or its ones
         //   complement at any location.
         //
         //   3 - if the search above succeeds, try to read the next frame
         //   ahead of that validation stamp.  If that frame is valid, the
         //   validation stamp that we found is likely to be in the footer of a
         //   valid frame if it is at least frame_size bytes away from the
         //   starting position (1).
         //
         // The algorithm will search ahead for either the space available or
         // the next ten frames.  If no valid frame is located within ten frame
         // sizes, the return value will be false.  If the end-of-file is
         // encountered while this is going on, an ExcEndOfFile object will be
         // thrown.  If the frame is encountered, the return value will be true
         // and the file pointer positioned at the beginning of that good
         // frame. 
         ////////////////////////////////////////////////////////////
         bool do_resynch();

         ////////////////////////////////////////////////////////////
         // get_current_file_offset
         //
         // Returns the current reading offset in the data file. 
         ////////////////////////////////////////////////////////////
         int8 get_current_file_offset();

         //@group The following methods access the fields container.

         ////////////////////////////////////////////////////////////
         // begin
         ////////////////////////////////////////////////////////////
         typedef fields_type::iterator iterator;
         typedef fields_type::const_iterator const_iterator;
         iterator begin()
         { return fields.begin(); }
         const_iterator begin() const
         { return fields.begin(); }

         ////////////////////////////////////////////////////////////
         // end
         ////////////////////////////////////////////////////////////
         iterator end()
         { return fields.end(); }
         const_iterator end() const
         { return fields.end(); }

         ////////////////////////////////////////////////////////////
         // size
         ////////////////////////////////////////////////////////////
         typedef fields_type::size_type size_type;
         size_type size() const
         { return fields.empty(); }

         ////////////////////////////////////////////////////////////
         // empty
         ////////////////////////////////////////////////////////////
         bool empty() const
         { return fields.empty(); }
         //@endgroup

         ////////////////////////////////////////////////////////////
         // get_tob1_header_len
         ////////////////////////////////////////////////////////////
         uint4 get_tob1_header_len() const
         {
            uint4 rtn = 0;
            if(tob1_secs_pos != 0xFFFFFFFF)
               rtn += 4;
            if(tob1_nsecs_pos != 0xFFFFFFFF)
               rtn += 4;
            if(tob1_record_no_pos != 0xFFFFFFFF)
               rtn += 4;
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // get_tob1_has_secs
         ////////////////////////////////////////////////////////////
         bool get_tob1_has_secs() const
         { return tob1_secs_pos != 0xFFFFFFFF; }

         ////////////////////////////////////////////////////////////
         // get_tob1_has_nsecs
         ////////////////////////////////////////////////////////////
         bool get_tob1_has_nsecs() const
         { return tob1_nsecs_pos != 0xFFFFFFFF; }

         ////////////////////////////////////////////////////////////
         // get_tob1_has_record_no
         ////////////////////////////////////////////////////////////
         bool get_tob1_has_record_no() const
         { return file_type == type_tob3 || tob1_record_no_pos != 0xFFFFFFFF; }

         ////////////////////////////////////////////////////////////
         // get_tob1_secs_pos
         ////////////////////////////////////////////////////////////
         uint4 get_tob1_secs_pos() const
         { return tob1_secs_pos; }

         ////////////////////////////////////////////////////////////
         // get_tob1_nsecs_pos
         ////////////////////////////////////////////////////////////
         uint4 get_tob1_nsecs_pos() const
         { return tob1_nsecs_pos; }

         ////////////////////////////////////////////////////////////
         // get_tob1_record_no_pos
         ////////////////////////////////////////////////////////////
         uint4 get_tob1_record_no_pos() const
         { return tob1_record_no_pos; }
      };
   };
};


#endif
