/* Csi.OsLoader.CstermLoader.h

   Copyright (C) 2004, 2011 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Monday 22 March 2004
   Last Change: Thursday 27 January 2011
   Last Commit: $Date: 2011-01-27 12:51:49 -0600 (Thu, 27 Jan 2011) $ 
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Csi_OsLoader_CstermLoader_h
#define Csi_OsLoader_CstermLoader_h

#include "Csi.OsLoader.OsLoaderBase.h"
#include "OneShot.h"
#include "Csi.ByteQueue.h"
#include "Csi.ReadFileMapping.h"


namespace Csi
{
   namespace OsLoader
   {
      ////////////////////////////////////////////////////////////
      // class CstermLoader
      //
      // Defines an object that implements the CsTerm os download protocol that
      // is used to send an operating system to the NL100, CR5000, CR1000, and
      // the CR9032.
      ////////////////////////////////////////////////////////////
      class CstermLoader:
         public OsLoaderBase,
         public OneShotClient
      {
      public:
         ////////////////////////////////////////////////////////////
         // constructor
         ////////////////////////////////////////////////////////////
         typedef Csi::SharedPtr<OneShot> timer_handle;
         enum init_method_type
         {
            init_assume_boot_mode,
            init_use_toboot,
            init_use_devconfig
         };
         CstermLoader(
            timer_handle &timer_,
            init_method_type init_method_ = init_assume_boot_mode);

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~CstermLoader();

         ////////////////////////////////////////////////////////////
         // get_file_extension
         ////////////////////////////////////////////////////////////
         char const *get_file_extension()
         {
            char const *rtn(OsLoaderBase::get_file_extension());
            if(*rtn == 0)
               rtn = "OBJ files (*.obj)|*.obj|OS Files (*.os)|*.os";
            return rtn;
         }

         ////////////////////////////////////////////////////////////
         // open_and_validate
         ////////////////////////////////////////////////////////////
         virtual void open_and_validate(
            char const *os_file_name);

         ////////////////////////////////////////////////////////////
         // start_send
         ////////////////////////////////////////////////////////////
         virtual void start_send(
            driver_handle driver,
            EventReceiver *client);

         ////////////////////////////////////////////////////////////
         // cancel_send
         ////////////////////////////////////////////////////////////
         virtual void cancel_send();

         ////////////////////////////////////////////////////////////
         // on_receive
         ////////////////////////////////////////////////////////////
         virtual void on_receive(
            OsLoaderDriver *driver,
            void const *buff,
            uint4 buff_len);

      protected:
         ////////////////////////////////////////////////////////////
         // on_complete
         ////////////////////////////////////////////////////////////
         virtual void on_complete(
            char const *message,
            bool succeeded);

         ////////////////////////////////////////////////////////////
         // get_security_code
         ////////////////////////////////////////////////////////////
         virtual uint2 get_security_code() const
         { return 0; }

         ////////////////////////////////////////////////////////////
         // on_security_code_wrong
         //
         // Called when the security code provided by get_security_code() is
         // determined to be wrong (the device rejected the code provided).
         // The return value will determine whether the devconfig low level
         // will be retried or the send operation cancelled.  
         ////////////////////////////////////////////////////////////
         virtual bool on_security_code_wrong()
         { return false; }

         ////////////////////////////////////////////////////////////
         // send_status
         ////////////////////////////////////////////////////////////
         void send_status(char const *message);

         ////////////////////////////////////////////////////////////
         // onOneShotFired
         ////////////////////////////////////////////////////////////
         virtual void onOneShotFired(uint4 event_id);

      private:
         ////////////////////////////////////////////////////////////
         // on_error
         ////////////////////////////////////////////////////////////
         void on_error(char const *message);

         ////////////////////////////////////////////////////////////
         // start_synch
         ////////////////////////////////////////////////////////////
         void start_synch();

         ////////////////////////////////////////////////////////////
         // start_devconfig_reset
         ////////////////////////////////////////////////////////////
         void start_devconfig_reset();
         
         ////////////////////////////////////////////////////////////
         // check_for_terminal_prompt
         ////////////////////////////////////////////////////////////
         void check_for_terminal_prompt();

         ////////////////////////////////////////////////////////////
         // check_for_boot_prompt
         ////////////////////////////////////////////////////////////
         void check_for_boot_prompt();

         ////////////////////////////////////////////////////////////
         // check_for_devconfig_reset
         ////////////////////////////////////////////////////////////
         void check_for_devconfig_reset();
         
         ////////////////////////////////////////////////////////////
         // check_for_synch1
         ////////////////////////////////////////////////////////////
         void check_for_synch1();

         ////////////////////////////////////////////////////////////
         // check_for_synch2
         ////////////////////////////////////////////////////////////
         void check_for_synch2();

         ////////////////////////////////////////////////////////////
         // check_for_flash_erase1
         ////////////////////////////////////////////////////////////
         void check_for_flash_erase1();

         ////////////////////////////////////////////////////////////
         // check_for_flash_erase2
         ////////////////////////////////////////////////////////////
         void check_for_flash_erase2();

         ////////////////////////////////////////////////////////////
         // send_next
         ////////////////////////////////////////////////////////////
         void send_next();

         ////////////////////////////////////////////////////////////
         // check_for_sig
         ////////////////////////////////////////////////////////////
         void check_for_sig();

         ////////////////////////////////////////////////////////////
         // check_wait_after
         ////////////////////////////////////////////////////////////
         void check_wait_after();

      private:
         ////////////////////////////////////////////////////////////
         // init_method
         //
         // Specifies the method that will be used to force the device into boot mode.  
         ////////////////////////////////////////////////////////////
         init_method_type init_method;
         
         ////////////////////////////////////////////////////////////
         // os_file_name
         ////////////////////////////////////////////////////////////
         StrAsc os_file_name;

         ////////////////////////////////////////////////////////////
         // timer
         ////////////////////////////////////////////////////////////
         timer_handle timer;

         ////////////////////////////////////////////////////////////
         // file_sig
         ////////////////////////////////////////////////////////////
         uint2 file_sig;

         ////////////////////////////////////////////////////////////
         // state
         ////////////////////////////////////////////////////////////
         enum state_type
         {
            state_standby,      // the loader is ready to be opened
            state_open,         // the loader is ready to be started
            state_get_terminal_prompt, // get the terminal prompt
            state_to_boot,      // get the "BOOT!" prompt
            state_synch1,       // sending the synch byte
            state_synch2,       // waiting for the synch response
            state_erase_flash1, // erasing flash part 1
            state_erase_flash2, // erasing flash part 2
            state_erase_flash3, // wait short time before starting to send
            state_send,         // sending fragments
            state_wait_after,   // waiting after last fragment
            state_complete,     // response received after reboot
            state_error,         // an error occurred
            state_send_devconfig // sending a devconfig control command
         } state;

         ////////////////////////////////////////////////////////////
         // synch_id
         ////////////////////////////////////////////////////////////
         uint4 synch_id;

         ////////////////////////////////////////////////////////////
         // erase_flash_id
         ////////////////////////////////////////////////////////////
         uint4 erase_flash_id;

         ////////////////////////////////////////////////////////////
         // send_id
         ////////////////////////////////////////////////////////////
         uint4 send_id;

         ////////////////////////////////////////////////////////////
         // wait_after_id
         ////////////////////////////////////////////////////////////
         uint4 wait_after_id;
         
         ////////////////////////////////////////////////////////////
         // input
         ////////////////////////////////////////////////////////////
         SharedPtr<ReadFileMapping> input;
         
         ////////////////////////////////////////////////////////////
         // input_bytes
         //
         // Pointer to the shared memory from the input member.
         ////////////////////////////////////////////////////////////
         byte const *input_bytes;

         ////////////////////////////////////////////////////////////
         // input_bytes_len
         ////////////////////////////////////////////////////////////
         uint4 input_bytes_len;

         ////////////////////////////////////////////////////////////
         // bytes_sent
         ////////////////////////////////////////////////////////////
         uint4 bytes_sent;

         ////////////////////////////////////////////////////////////
         // receive_buffer
         ////////////////////////////////////////////////////////////
         ByteQueue receive_buffer;

         ////////////////////////////////////////////////////////////
         // retry_count
         ////////////////////////////////////////////////////////////
         uint4 retry_count;

         ////////////////////////////////////////////////////////////
         // fragment_sig
         ////////////////////////////////////////////////////////////
         uint2 fragment_sig;

         ////////////////////////////////////////////////////////////
         // send_buffer
         ////////////////////////////////////////////////////////////
         ByteQueue send_buffer;

         ////////////////////////////////////////////////////////////
         // devconfig_buffer
         ////////////////////////////////////////////////////////////
         StrBin devconfig_buffer;

         ////////////////////////////////////////////////////////////
         // should_unquote_next
         ////////////////////////////////////////////////////////////
         bool should_unquote_next;

         ////////////////////////////////////////////////////////////
         // reboot_base
         //
         // Keeps track of the time that has expired since the last fragment was sent. If the time
         // from this base exceeds 30 seconds without receiving acks from the datalogger, an error
         // will be reported. 
         ////////////////////////////////////////////////////////////
         uint4 reboot_base;
      };
   };
};


#endif
