/* Cora.DataSources.Request.h

   Copyright (C) 2008, 2016 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Monday 04 August 2008
   Last Change: Thursday 21 January 2016
   Last Commit: $Date: 2016-01-21 12:37:55 -0600 (Thu, 21 Jan 2016) $
   Last Changed by: $Author: jon $

*/

#pragma once
#ifndef Cora_DataSources_Request_h
#define Cora_DataSources_Request_h

#include "Cora.Broker.Record.h"


namespace Cora
{
   namespace DataSources
   {
      ////////////////////////////////////////////////////////////
      // class WartBase
      //
      // Defines a base class for a "wart" that can be associated with a
      // request by a data source to maintain information that is expensive to
      // generate from the request URI
      ////////////////////////////////////////////////////////////
      class WartBase
      {
      public:
         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~WartBase()
         { }
      };

      
      ////////////////////////////////////////////////////////////
      // class Request
      ////////////////////////////////////////////////////////////
      class SourceBase;
      class SinkBase;
      class Request
      {
      public:
         ////////////////////////////////////////////////////////////
         // default constructor
         ////////////////////////////////////////////////////////////
         Request(SinkBase *sink_ = 0, StrUni const &uri_ = L"");

         ////////////////////////////////////////////////////////////
         // copy constructor
         ////////////////////////////////////////////////////////////
         Request(Request const &other);

         ////////////////////////////////////////////////////////////
         // copy operator
         ////////////////////////////////////////////////////////////
         Request &operator =(Request const &other);

         ////////////////////////////////////////////////////////////
         // destructor
         ////////////////////////////////////////////////////////////
         virtual ~Request()
         { wart.clear(); }

         ////////////////////////////////////////////////////////////
         // equality operator
         ////////////////////////////////////////////////////////////
         bool operator ==(Request const &other) const;

         ////////////////////////////////////////////////////////////
         // inequality operator
         ////////////////////////////////////////////////////////////
         bool operator !=(Request const &other) const
         { return !(*this == other); }
         
         ////////////////////////////////////////////////////////////
         // get_state
         ////////////////////////////////////////////////////////////
         enum state_type
         {
            state_inactive,
            state_pending,
            state_started,
            state_error,
            state_satisfied,
            state_remove_pending
         };
         state_type get_state() const
         { return state; }

         ////////////////////////////////////////////////////////////
         // set_state
         ////////////////////////////////////////////////////////////
         void set_state(SourceBase *source_, state_type state_);

         ////////////////////////////////////////////////////////////
         // get_sink
         ////////////////////////////////////////////////////////////
         SinkBase *get_sink()
         { return sink; }
         SinkBase const *get_sink() const
         { return sink; }

         ////////////////////////////////////////////////////////////
         // set_sink
         ////////////////////////////////////////////////////////////
         void set_sink(SinkBase *sink_)
         { sink = sink_; }

         ////////////////////////////////////////////////////////////
         // get_source
         ////////////////////////////////////////////////////////////
         SourceBase *get_source()
         { return source; }
         SourceBase const *get_source() const
         { return source; }

         ////////////////////////////////////////////////////////////
         // set_source
         ////////////////////////////////////////////////////////////
         void set_source(SourceBase *source_)
         { source = source_; }

         ////////////////////////////////////////////////////////////
         // get_uri
         ////////////////////////////////////////////////////////////
         StrUni const &get_uri() const
         { return uri; }

         /**
          * @param value Specifies the new value for the URI.
          */
         void set_uri(StrUni const &value)
         { uri = value; }
            
         ////////////////////////////////////////////////////////////
         // get_start_option
         ////////////////////////////////////////////////////////////
         enum start_option_type
         {
            start_at_record = 1,
            start_at_time = 2,
            start_at_newest = 3,
            start_after_newest = 4,
            start_relative_to_newest = 5,
            start_at_offset_from_newest = 6,
            start_date_query = 7
         };
         start_option_type get_start_option() const
         { return start_option; }

         ////////////////////////////////////////////////////////////
         // set_start_at_record
         //
         // Sets up this request to start at the specified record number.  The
         // file_mark_no parameter is ignored for some data sources (files,
         // databases, and HTTP).  If set to a value of 0xFFFFFFFF for the
         // LgrNet source, the LgrNet server will resolve to the newest file
         // mark.
         //
         // The start_time parameter can now be optionally set and, for some
         // data sources (file and database), this parameter will influence the
         // results of the query.  
         ////////////////////////////////////////////////////////////
         void set_start_at_record(
            uint4 file_mark_no_,
            uint4 record_no_,
            Csi::LgrDate const &start_time_ = 0);

         ////////////////////////////////////////////////////////////
         // set_start_at_time
         ////////////////////////////////////////////////////////////
         void set_start_at_time(Csi::LgrDate const &start_time_);

         ////////////////////////////////////////////////////////////
         // set_start_at_newest
         ////////////////////////////////////////////////////////////
         void set_start_at_newest();

         ////////////////////////////////////////////////////////////
         // set_start_after_newest
         ////////////////////////////////////////////////////////////
         void set_start_after_newest();

         ////////////////////////////////////////////////////////////
         // set_start_relative_to_newest
         ////////////////////////////////////////////////////////////
         void set_start_relative_to_newest(int8 backfill_interval_);

         ////////////////////////////////////////////////////////////
         // set_start_at_offset_from_newest
         ////////////////////////////////////////////////////////////
         void set_start_at_offset_from_newest(uint4 start_record_offset_);

         ////////////////////////////////////////////////////////////
         // set_query_times
         //
         // Sets up the request to query for a half-open interval of date
         // ranges.  If this option is used, the data sources will use the
         // provided range to specify a query to the source and, when all the
         // available records for that query have been collected, the state
         // will be set to state_satisfied and the request will be removed from
         // the source.
         ////////////////////////////////////////////////////////////
         void set_query_times(Csi::LgrDate const &begin, Csi::LgrDate const &end);

         ////////////////////////////////////////////////////////////
         // get_order_option
         ////////////////////////////////////////////////////////////
         enum order_option_type
         {
            order_collected = 1,
            order_logged_with_holes = 2,
            order_logged_without_holes = 3,
            order_real_time = 4
         };
         order_option_type get_order_option() const
         { return order_option; }

         ////////////////////////////////////////////////////////////
         // is_valid_order_option
         ////////////////////////////////////////////////////////////
         static bool is_valid_order_option(order_option_type option);

         ////////////////////////////////////////////////////////////
         // set_order_option
         ////////////////////////////////////////////////////////////
         void set_order_option(order_option_type order_option);

         ////////////////////////////////////////////////////////////
         // get_file_mark_no
         ////////////////////////////////////////////////////////////
         uint4 get_file_mark_no() const
         { return file_mark_no; }

         ////////////////////////////////////////////////////////////
         // get_record_no
         ////////////////////////////////////////////////////////////
         uint4 get_record_no() const
         { return record_no; }

         ////////////////////////////////////////////////////////////
         // get_start_time
         ////////////////////////////////////////////////////////////
         Csi::LgrDate const &get_start_time() const
         { return start_time; }


         ////////////////////////////////////////////////////////////
         // get_end_time
         ////////////////////////////////////////////////////////////
         Csi::LgrDate const &get_end_time() const
         { return end_time; }

         ////////////////////////////////////////////////////////////
         // get_backfill_interval
         ////////////////////////////////////////////////////////////
         int8 get_backfill_interval() const
         { return backfill_interval; }

         ////////////////////////////////////////////////////////////
         // get_start_record_offset
         ////////////////////////////////////////////////////////////
         uint4 get_start_record_offset() const
         { return start_record_offset; }

         ////////////////////////////////////////////////////////////
         // get_report_offset
         ////////////////////////////////////////////////////////////
         int8 get_report_offset() const
         { return report_offset; }

         ////////////////////////////////////////////////////////////
         // set_report_offset
         ////////////////////////////////////////////////////////////
         void set_report_offset(int8 offset)
         { report_offset = offset; }

         ////////////////////////////////////////////////////////////
         // get_begin_index
         ////////////////////////////////////////////////////////////
         uint4 get_begin_index() const
         { return begin_index; }

         ////////////////////////////////////////////////////////////
         // get_end_index
         ////////////////////////////////////////////////////////////
         uint4 get_end_index() const
         { return end_index; }

         ////////////////////////////////////////////////////////////
         // set_cache_size_controller
         ////////////////////////////////////////////////////////////
         void set_cache_size_controller(uint4 cache_size_controller_)
         { cache_size_controller = cache_size_controller_; }

         ////////////////////////////////////////////////////////////
         // get_cache_size_controller
         ////////////////////////////////////////////////////////////
         uint4 get_cache_size_controller() const
         { return cache_size_controller; }

         ////////////////////////////////////////////////////////////
         // copy_start_options
         //
         // Copies the start option and order option and related parameters
         // from the other request instance.
         ////////////////////////////////////////////////////////////
         void copy_start_options(Request const &other);

         ////////////////////////////////////////////////////////////
         // set_value_indices
         //
         // Sets the value indices for this request based upon the contents of
         // the record description and the specified column name.  Even thoough
         // individual source may have different URI syntax, the syntax for the
         // column name ought to be the same.  This method takes advantage of
         // that similarity.
         ////////////////////////////////////////////////////////////
         void set_value_indices(
            Cora::Broker::Record const &record_,
            StrUni const &column_name);
      
         ///////////////////////////////////////////////////////////
         // get_source_name
         ///////////////////////////////////////////////////////////
         StrUni get_source_name() const;

         ////////////////////////////////////////////////////////////
         // is_frozen
         ////////////////////////////////////////////////////////////
         bool is_frozen() const
         { return frozen; }

         ////////////////////////////////////////////////////////////
         // freeze
         ////////////////////////////////////////////////////////////
         void freeze()
         { frozen = true; }

         ////////////////////////////////////////////////////////////
         // thaw
         ////////////////////////////////////////////////////////////
         void thaw()
         { frozen = false; }

         ////////////////////////////////////////////////////////////
         // is_compatible
         ////////////////////////////////////////////////////////////
         bool is_compatible(Request const &other) const;

         ////////////////////////////////////////////////////////////
         // get_wart
         ////////////////////////////////////////////////////////////
         Csi::SharedPtr<WartBase> &get_wart()
         { return wart; }

         ////////////////////////////////////////////////////////////
         // set_wart
         ////////////////////////////////////////////////////////////
         void set_wart(Csi::SharedPtr<WartBase> wart_)
         { wart = wart_; }

         ////////////////////////////////////////////////////////////
         // get_use_table_index
         ////////////////////////////////////////////////////////////
         bool get_use_table_index() const
         { return use_table_index; }

         ////////////////////////////////////////////////////////////
         // set_use_table_index
         ////////////////////////////////////////////////////////////
         void set_use_table_index(bool use_table_index = true);

         ////////////////////////////////////////////////////////////
         // get_expect_more_data
         ////////////////////////////////////////////////////////////
         bool get_expect_more_data() const
         { return expect_more_data; }

         ////////////////////////////////////////////////////////////
         // set_expect_more_data
         ////////////////////////////////////////////////////////////
         void set_expect_more_data(bool expect_more_data_)
         {
            if(use_table_index)
               expect_more_data = expect_more_data_;
         }

         ////////////////////////////////////////////////////////////
         // get_cacheable
         ////////////////////////////////////////////////////////////
         bool get_cacheable() const
         { return cacheable; }

         ////////////////////////////////////////////////////////////
         // set_cacheable
         ////////////////////////////////////////////////////////////
         void set_cacheable(bool value)
         { cacheable = value; }

         ///////////////////////////////////////////////////////////
         // get_js_name
         ///////////////////////////////////////////////////////////
         StrUni const &get_js_name() const
         { return js_name; }

         ///////////////////////////////////////////////////////////
         // set_js_name
         ///////////////////////////////////////////////////////////
         void set_js_name(StrUni const &js_name_)
         { js_name = js_name_; }

         ////////////////////////////////////////////////////////////
         // get_app_data
         ////////////////////////////////////////////////////////////
         void *get_app_data()
         { return app_data; }

         ////////////////////////////////////////////////////////////
         // set_app_data
         ////////////////////////////////////////////////////////////
         void set_app_data(void *app_data_)
         { app_data = app_data_; }
         
      private:
         ////////////////////////////////////////////////////////////
         // sink
         ////////////////////////////////////////////////////////////
         SinkBase *sink;

         ////////////////////////////////////////////////////////////
         // source
         ////////////////////////////////////////////////////////////
         SourceBase *source;

         ////////////////////////////////////////////////////////////
         // state
         ////////////////////////////////////////////////////////////
         state_type state;

         ////////////////////////////////////////////////////////////
         // uri
         ////////////////////////////////////////////////////////////
         StrUni uri;

         ////////////////////////////////////////////////////////////
         // start_option
         ////////////////////////////////////////////////////////////
         start_option_type start_option;

         ////////////////////////////////////////////////////////////
         // order_option
         ////////////////////////////////////////////////////////////
         order_option_type order_option;

         ////////////////////////////////////////////////////////////
         // file_mark_no
         ////////////////////////////////////////////////////////////
         uint4 file_mark_no;

         ////////////////////////////////////////////////////////////
         // record_no
         ////////////////////////////////////////////////////////////
         uint4 record_no;

         ////////////////////////////////////////////////////////////
         // start_time
         ////////////////////////////////////////////////////////////
         Csi::LgrDate start_time;

         ////////////////////////////////////////////////////////////
         // end_time
         ////////////////////////////////////////////////////////////
         Csi::LgrDate end_time;

         ////////////////////////////////////////////////////////////
         // backfill_time
         ////////////////////////////////////////////////////////////
         int8 backfill_interval;

         ////////////////////////////////////////////////////////////
         // start_record_offset
         ////////////////////////////////////////////////////////////
         uint4 start_record_offset;

         ////////////////////////////////////////////////////////////
         // report_offset
         //
         // Specifies an offset that should be applied to the begin date for the request in report
         // mode. 
         ////////////////////////////////////////////////////////////
         int8 report_offset;

         ////////////////////////////////////////////////////////////
         // begin_index
         //
         // Specifies the begin value index for the set of record values
         // covered by this request.   
         ////////////////////////////////////////////////////////////
         uint4 begin_index;

         ////////////////////////////////////////////////////////////
         // end_index
         //
         // Specifies the end value index for the set of record values covered
         // by this request.  This side of the interval will be considered to
         // be open as in [begin_index, end_index).
         ////////////////////////////////////////////////////////////
         uint4 end_index;

         ////////////////////////////////////////////////////////////
         // cache_size_controller
         ////////////////////////////////////////////////////////////
         uint4 cache_size_controller;

         ////////////////////////////////////////////////////////////
         // frozen
         //
         // Set to true when the request has been added to the manager.   Can
         // also be set to true by the application.  Once set, this flag will
         // prevent any further changes to the starting condition for this
         // request until thaw() is called. 
         ////////////////////////////////////////////////////////////
         bool frozen;

         ////////////////////////////////////////////////////////////
         // wart
         ////////////////////////////////////////////////////////////
         Csi::SharedPtr<WartBase> wart;

         ////////////////////////////////////////////////////////////
         // use_table_index
         //
         // Controls whether the source will use a table data index to
         // determine the value of the expect_more member.  By default, this
         // value will be set to false and the expect_more member will always
         // be set to true.  If it is set, however, the source (particularly a
         // LgrNet source) will attempt to determine whether there is more data
         // to immediately send.
         ////////////////////////////////////////////////////////////
         bool use_table_index;

         ////////////////////////////////////////////////////////////
         // bool expect_more_data
         //
         // Set to true if the data source expects that more data will be
         // available in a relatively short amount of time.  
         ////////////////////////////////////////////////////////////
         bool expect_more_data;

         ////////////////////////////////////////////////////////////
         // cacheable
         //
         // This property can be set to true by the data source when there can
         // be some benefit to maintaining this request even though the sink
         // for the request has no reason to keep it.  
         ////////////////////////////////////////////////////////////
         bool cacheable;

         ///////////////////////////////////////////////////////////
         // js_name
         //
         // This property is used when generating WebQuery objects
         // associated with this request.  It is used to identify specific
         // WebQueries and to facilitate the operation of a ReportRange
         // control in RTMC.
         ///////////////////////////////////////////////////////////
         StrUni js_name;

         ////////////////////////////////////////////////////////////
         // app_data
         //
         // Reference to an application specified object such as an expression
         // variable.  This value can be set with set_app_data() and retrieved
         // using get_app_data().
         ////////////////////////////////////////////////////////////
         void *app_data;
      };
   };
};


#endif
