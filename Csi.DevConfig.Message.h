/* Csi.DevConfig.Message.h

   Copyright (C) 2003, 2012 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Thursday 20 November 2003
   Last Change: Tuesday 16 October 2012
   Last Commit: $Date: 2012-10-16 13:56:36 -0600 (Tue, 16 Oct 2012) $ 
   Last Changed by: $Author: jon $

*/

#ifndef Csi_DevConfig_Message_h
#define Csi_DevConfig_Message_h

#include "Packet.h"
#include "Csi.ByteOrder.h"
#include "Csi.DevConfig.Defs.h"


namespace Csi
{
   namespace DevConfig
   {
      ////////////////////////////////////////////////////////////
      // class Message
      ////////////////////////////////////////////////////////////
      class Message: public ::Packet
      {
      public:
         ////////////////////////////////////////////////////////////
         // packet_type_byte
         ////////////////////////////////////////////////////////////
         static byte const packet_type_byte;

         ////////////////////////////////////////////////////////////
         // header_len
         ////////////////////////////////////////////////////////////
         static uint4 const header_len;
         
         ////////////////////////////////////////////////////////////
         // default constructor
         ////////////////////////////////////////////////////////////
         Message();

         ////////////////////////////////////////////////////////////
         // reading constructor
         ////////////////////////////////////////////////////////////
         Message(
            void const *buff,
            uint4 buff_len,
            bool copy_buff = true);

         //@group header parameter access methods
         ////////////////////////////////////////////////////////////
         // get_message_type
         ////////////////////////////////////////////////////////////
         typedef Messages::message_id_type message_id_type;
         message_id_type get_message_type();

         ////////////////////////////////////////////////////////////
         // set_message_type
         ////////////////////////////////////////////////////////////
         void set_message_type(message_id_type message_type);

         ////////////////////////////////////////////////////////////
         // get_tran_no
         ////////////////////////////////////////////////////////////
         byte get_tran_no();

         ////////////////////////////////////////////////////////////
         // set_tran_no
         ////////////////////////////////////////////////////////////
         void set_tran_no(byte tran_no);
         //@endgroup

         //@group streaming methods overloaded to specify big endian
         ////////////////////////////////////////////////////////////
         // readUInt2
         ////////////////////////////////////////////////////////////
         uint2 readUInt2()
         { return Packet::readUInt2(!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // readInt2
         ////////////////////////////////////////////////////////////
         int2 readInt2()
         { return Packet::readInt2(!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // readUInt4
         ////////////////////////////////////////////////////////////
         uint4 readUInt4()
         { return Packet::readUInt4(!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // readInt4
         ////////////////////////////////////////////////////////////
         int4 readInt4()
         { return Packet::readInt4(!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // readIeee4
         ////////////////////////////////////////////////////////////
         float readIeee4()
         { return Packet::readIeee4(!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // readIeee8
         ////////////////////////////////////////////////////////////
         double readIeee8()
         { return Packet::readIeee8(!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // addUInt2
         ////////////////////////////////////////////////////////////
         void addUInt2(uint2 val)
         { Packet::addUInt2(val,!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // addInt2
         ////////////////////////////////////////////////////////////
         void addInt2(int2 val)
         { Packet::addInt2(val,!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // addUInt4
         ////////////////////////////////////////////////////////////
         void addUInt4(uint4 val)
         { Packet::addUInt4(val,!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // addInt4
         ////////////////////////////////////////////////////////////
         void addInt4(int4 val)
         { Packet::addInt4(val,!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // addIeee4
         ////////////////////////////////////////////////////////////
         void addIeee4(float val)
         { Packet::addIeee4(val,!is_big_endian()); }

         ////////////////////////////////////////////////////////////
         // addIeee8
         ////////////////////////////////////////////////////////////
         void addIeee8(double val)
         { Packet::addIeee8(val, !is_big_endian()); }
         
         //@endgroup

         ////////////////////////////////////////////////////////////
         // get_body
         //
         // Returns the portion of the message following the header
         ////////////////////////////////////////////////////////////
         void const *get_body()
         { return getMsg() + get_headerLen(); }
         
         ////////////////////////////////////////////////////////////
         // get_body_len
         //
         // Calculates the number of bytes that are stored in the message
         // (excluding the header length)
         ////////////////////////////////////////////////////////////
         uint4 get_body_len() const
         { return length() - get_headerLen(); }

         ////////////////////////////////////////////////////////////
         // get_available
         //
         // Calculates the number of bytes that can be stored in this message
         // without exceeding packet size limitations
         ////////////////////////////////////////////////////////////
         uint4 get_available(uint4 max_body_len = 998) const
         {
            uint4 rtn = 0;
            uint4 body_len = get_body_len();
            if(body_len < max_body_len)
               rtn = max_body_len - body_len;
            return rtn;
         }
      };
   };
};


#endif
